<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KSCommonReactor</name>
    </assembly>
    <members>
        <member name="T:KS.Reactor.Client.CubicInterpolator`1">
            Generic cubic interpolation that smoothly moves from zero with an initial velocity to a stop at a target value.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.CubicInterpolator`1.#ctor(KS.Reactor.Client.IMath{`0})" -->
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Init(`0,System.Single)">
            Initializes a cubic curve with initial velocity being the velocity at the time Interpolate was last called.
            You must call this before calling Interpolate.
            
            @param   T target to end interpolation at.
            @param   float duration in seconds to get to the target.
        </member>
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Interpolate(System.Single)">
            Gets the value at a given time. You must call Init before calling this.
            
            @param   float t - time.
            @return  T interpolated value.
        </member>
        <member name="M:KS.Reactor.Client.CubicInterpolator`1.Finish">
            Finishes interpolation so the next curve will use zero for initial velocity. After this is called,
            you cannot call Interpolate again until Init is called.
        </member>
        <member name="T:KS.Reactor.Client.IMath`1">
            Templated interface for basic math operations.
        </member>
        <member name="P:KS.Reactor.Client.IMath`1.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Add(`0,`0)">
            Addition
            
            @param   T lhs
            @param   T rhs
            @return  T lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Subtract(`0,`0)">
            Subtraction
            
            @param   T lhs
            @param   T rhs
            @return  T lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.IMath`1.Multiply(`0,System.Single)">
            Scalar multiplication
            
            @param   T value
            @param   T scalar
            @return  T value * scalar
        </member>
        <member name="T:KS.Reactor.Client.FloatMath">
            float math operations
        </member>
        <member name="P:KS.Reactor.Client.FloatMath.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Add(System.Single,System.Single)">
            float addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Subtract(System.Single,System.Single)">
            float subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.FloatMath.Multiply(System.Single,System.Single)">
            float multiplication
            
            @param   float value
            @param   float scalar
            @return  float value * scalar
        </member>
        <member name="T:KS.Reactor.Client.Vector2Math">
            ksVector2 math operations
        </member>
        <member name="P:KS.Reactor.Client.Vector2Math.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            ksVector2 addition
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            ksVector2 subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector2Math.Multiply(KS.Reactor.ksVector2,System.Single)">
            ksVector2 scalar multiplication
            
            @param   ksVector2 value
            @param   float scalar
            @return  ksVector2 value * scalar
        </member>
        <member name="T:KS.Reactor.Client.Vector3Math">
            ksVector3 math operations
        </member>
        <member name="P:KS.Reactor.Client.Vector3Math.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Add(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            ksVector3 addition
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            ksVector3 subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.Vector3Math.Multiply(KS.Reactor.ksVector3,System.Single)">
            ksVector3 scalar multiplication
            
            @param   ksVector3 value
            @param   float scalar
            @return  ksVector3 value * scalar
        </member>
        <member name="T:KS.Reactor.Client.ISpace`2">
            Templated interface for defining a mathematical space with the following operations:
            
             Vector + Delta = Vector
             Vector - Vector = Delta
             Delta * float = Delta
             Delta + Delta = Delta (may not be commutative)
             Magnitude(Delta - Delta) = float
        </member>
        <member name="P:KS.Reactor.Client.ISpace`2.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Add(`0,`1)">
            Addition
            
            @param   Vector lhs
            @param   Delta rhs
            @return  Vector lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Subtract(`0,`0)">
            Subtraction
            
            @param   Vector lhs
            @param   Vector rhs
            @return  Delta lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Multiply(`1,System.Single)">
            Scalar multiplication
            
            @param   Delta lhs
            @param   float rhs
            @return  Delta lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.AddDeltas(`1,`1)">
            Delta addition. May not be commutative.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  Delta lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.CompareDeltas(`1,`1)">
            Gets the magnitude of the difference between two deltas.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.Interpolate(`0,`0,System.Single)">
            Interpolates between two vectors.
            
            @param   Vector from - vector to interpolate from.
            @param   Vector to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  Vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.MoveTowards(`0,`0,System.Single)">
            Moves a Vector towards another.
            
            @param    Vector start point.
            @param    Vector target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   Vector
        </member>
        <member name="M:KS.Reactor.Client.ISpace`2.AreEqual(`0,`0)">
            Check if two Vectors are equal.
            
            @param   Vector a
            @param   Vector b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.OneSpace">
            1D float math.
        </member>
        <member name="P:KS.Reactor.Client.OneSpace.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Add(System.Single,System.Single)">
            Addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Subtract(System.Single,System.Single)">
            Subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Multiply(System.Single,System.Single)">
            Multiplication
            
            @param   float lhs
            @param   float rhs
            @return  float lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.AddDeltas(System.Single,System.Single)">
            Delta addition.
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.CompareDeltas(System.Single,System.Single)">
            Gets the magnitude of the difference between two deltas.
            
            @param   float lhs
            @param   float rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.Interpolate(System.Single,System.Single,System.Single)">
            Linearly interpolates between two floats.
            
            @param   float from - value to interpolate from.
            @param   float to - value to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  float
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.MoveTowards(System.Single,System.Single,System.Single)">
            Moves a float towards another.
            
            @param    float start value.
            @param    float target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   float
        </member>
        <member name="M:KS.Reactor.Client.OneSpace.AreEqual(System.Single,System.Single)">
            Check if two floats are equal.
            
            @param   float a
            @param   float b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.TwoSpace">
            2D space
        </member>
        <member name="P:KS.Reactor.Client.TwoSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Addition
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Multiply(KS.Reactor.ksVector2,System.Single)">
            Scalar multiplication
            
            @param   ksVector2 lhs
            @param   float rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.AddDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Delta addition.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.CompareDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.Interpolate(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Linearly interpolates between two vectors.
            
            @param   ksVector2 from - vector to interpolate from.
            @param   ksVector2 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector2
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.MoveTowards(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Moves a ksVector2 towards another.
            
            @param    ksVector2 start point.
            @param    ksVector2 target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector2
        </member>
        <member name="M:KS.Reactor.Client.TwoSpace.AreEqual(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Check if two ksVector2s are equal.
            
            @param   ksVector2 a
            @param   ksVector2 b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.ThreeSpace">
            3D space
        </member>
        <member name="P:KS.Reactor.Client.ThreeSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Add(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Addition
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Multiply(KS.Reactor.ksVector3,System.Single)">
            Scalar multiplication
            
            @param   ksVector3 lhs
            @param   float rhs
            @return  ksVector3 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.AddDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Delta addition.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.CompareDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.Interpolate(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Linearly interpolates between two vectors.
            
            @param   ksVector3 from - vector to interpolate from.
            @param   ksVector3 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.MoveTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Moves a ksVector3 towards another.
            
            @param    ksVector3 start point.
            @param    ksVector3 target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector3
        </member>
        <member name="M:KS.Reactor.Client.ThreeSpace.AreEqual(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Check if two ksVector3s are equal.
            
            @param   ksVector3 a
            @param   ksVector3 b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.ColorSpace">
            Color space
        </member>
        <member name="P:KS.Reactor.Client.ColorSpace.Zero">
            Zero color
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Add(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Addition
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Subtract(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Subtraction
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Multiply(KS.Reactor.ksColor,System.Single)">
            Scalar multiplication
            
            @param   ksColor lhs
            @param   float rhs
            @return  ksColor lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.AddDeltas(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Delta addition.
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  ksColor lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.CompareDeltas(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksColor lhs
            @param   ksColor rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.Interpolate(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            Linearly interpolates between two colors.
            
            @param   ksColor from - ksColor to interpolate from.
            @param   ksColor to - ksColor to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksColor
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.MoveTowards(KS.Reactor.ksColor,KS.Reactor.ksColor,System.Single)">
            Moves a ksColor towards another.
            
            @param    ksColor start color.
            @param    ksColor target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksColor
        </member>
        <member name="M:KS.Reactor.Client.ColorSpace.AreEqual(KS.Reactor.ksColor,KS.Reactor.ksColor)">
            Check if two ksColors are equal.
            
            @param   ksColor a
            @param   ksColor b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.RangeSpace">
            Finite 1D space that wraps around.
        </member>
        <member name="P:KS.Reactor.Client.RangeSpace.Zero">
            Zero
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.#ctor(System.Single,System.Single)">
            Constructor
            
            @param   float min value in the range (inclusive).
            @param   float max value in the range (exclusive).
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Add(System.Single,System.Single)">
            Addition
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Subtract(System.Single,System.Single)">
            Subtraction
            
            @param   float lhs
            @param   float rhs
            @return  float lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Multiply(System.Single,System.Single)">
            Multiplication
            
            @param   float lhs
            @param   float rhs
            @return  float lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.AddDeltas(System.Single,System.Single)">
            Delta addition.
            
            @param   float lhs
            @param   float rhs
            @return  float lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.CompareDeltas(System.Single,System.Single)">
            Gets the magnitude of the difference between two deltas.
            
            @param   float lhs
            @param   float rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.Interpolate(System.Single,System.Single,System.Single)">
            Spherically interpolates between two floats.
            
            @param   float from - value to interpolate from.
            @param   float to - value to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  float
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.MoveTowards(System.Single,System.Single,System.Single)">
            Moves a float towards another.
            
            @param    float start value.
            @param    float target to move towards.
            @param    float distance to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   float
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.SetRange(System.Single,System.Single)">
            Change the min and max range
            
            @param   float min
            @param   float max
        </member>
        <member name="M:KS.Reactor.Client.RangeSpace.AreEqual(System.Single,System.Single)">
            Check if two wrapped floats are equal.
            
            @param   ksColor a
            @param   ksColor b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.CircleSpace">
            2D space with spherical interpolation.
        </member>
        <member name="P:KS.Reactor.Client.CircleSpace.Zero">
            Zero vector
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Add(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Addition
            
            @param   ksVector2 direction
            @param   ksVector2 delta (x = delta radians, y = delta magnitude)
            @return  direction + delta
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Subtract(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Subtraction
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 delta (x = delta radians, y = delta magnitude)
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Multiply(KS.Reactor.ksVector2,System.Single)">
            Scalar multiplication
            
            @param   ksVector2 lhs
            @param   float rhs
            @return  ksVector2 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.AddDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Delta addition.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  ksVector2 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.CompareDeltas(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector2 lhs
            @param   ksVector2 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.Interpolate(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Spherically interpolates between two vectors.
            
            @param   ksVector2 from - vector to interpolate from.
            @param   ksVector2 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector2
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.MoveTowards(KS.Reactor.ksVector2,KS.Reactor.ksVector2,System.Single)">
            Rotates a ksVector2 towards another.
            
            @param    ksVector2 start point.
            @param    ksVector2 target to move towards.
            @param    float amount to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector2
        </member>
        <member name="M:KS.Reactor.Client.CircleSpace.AreEqual(KS.Reactor.ksVector2,KS.Reactor.ksVector2)">
            Check if two ksVector2s are equal.
            
            @param   ksVector2 a
            @param   ksVector2 b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.SphereSpace">
            3D space with spherical interpolation.
        </member>
        <member name="T:KS.Reactor.Client.SphereSpace.Delta">
            Spherical delta
        </member>
        <member name="F:KS.Reactor.Client.SphereSpace.Delta.Angular">
            Delta angular in radians.
        </member>
        <member name="F:KS.Reactor.Client.SphereSpace.Delta.Magnitude">
            Delta magnitude
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Delta.#cctor">
            Static initialization. Registers delegates for converting to and from ksMultiType.
        </member>
        <member name="P:KS.Reactor.Client.SphereSpace.Zero">
            Zero delta
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Add(KS.Reactor.ksVector3,KS.Reactor.Client.SphereSpace.Delta)">
            Addition
            
            @param   ksVector3 direction
            @param   Delta delta
            @return  direction + delta
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Subtract(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Subtraction
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  Delta lhs - rhs
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Multiply(KS.Reactor.Client.SphereSpace.Delta,System.Single)">
            Scalar multiplication
            
            @param   Delta delta
            @param   float scalar
            @return  delta * scalar
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.AddDeltas(KS.Reactor.Client.SphereSpace.Delta,KS.Reactor.Client.SphereSpace.Delta)">
            Delta addition. Non-commutative.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  Delta lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.CompareDeltas(KS.Reactor.Client.SphereSpace.Delta,KS.Reactor.Client.SphereSpace.Delta)">
            Gets the magnitude of the difference between two deltas.
            
            @param   Delta lhs
            @param   Delta rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.Interpolate(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Spherically interpolates between two vectors.
            
            @param   ksVector3 from - vector to interpolate from.
            @param   ksVector3 to - vector to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.MoveTowards(KS.Reactor.ksVector3,KS.Reactor.ksVector3,System.Single)">
            Rotates a ksVector3 towards another.
            
            @param    ksVector3 start point.
            @param    ksVector3 target to move towards.
            @param    float amount to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksVector3
        </member>
        <member name="M:KS.Reactor.Client.SphereSpace.AreEqual(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Check if two ksVector3s are equal.
            
            @param   ksVector3 a
            @param   ksVector3 b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.RotationSpace">
            Rotation space
        </member>
        <member name="P:KS.Reactor.Client.RotationSpace.Zero">
            Zero angular displacement
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Add(KS.Reactor.ksQuaternion,KS.Reactor.ksVector3)">
            Addition
            
            @param   ksQuaternion rotation
            @param   ksVector3 angularDisplacement
            @return  ksQuaternion rotation + angularDisplacement
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Subtract(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            Subtraction
            
            @param   ksQuaternion lhs
            @param   ksQuaternion rhs
            @return  ksVector3 angular displacement from rhs to lhs.
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Multiply(KS.Reactor.ksVector3,System.Single)">
            Scalar multiplication
            
            @param   ksVector3 lhs
            @param   float rhs
            @return  ksVector3 lhs * rhs
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.AddDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Delta addition. Non-commutative.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  ksVector3 lhs + rhs
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.CompareDeltas(KS.Reactor.ksVector3,KS.Reactor.ksVector3)">
            Gets the magnitude of the difference between two deltas.
            
            @param   ksVector3 lhs
            @param   ksVector3 rhs
            @return  float magnitude(lhs - rhs)
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.Interpolate(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            Spherically interpolates between two quaternions.
            
            @param   ksQuaternion from - quaternion to interpolate from.
            @param   ksQuaternion to - quaternion to interpolate to.
            @param   float t - amount to interpolate between 0 and 1.
            @return  ksQuaternion
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.MoveTowards(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion,System.Single)">
            Rotates a quaternion towards another.
            
            @param    ksQuaternion start quaternion.
            @param    ksQuaternion target to move towards.
            @param    float degrees to move. It will not overshoot the target. 
                         Negative values will move away from the target.
            @return   ksQuaternion
        </member>
        <member name="M:KS.Reactor.Client.RotationSpace.AreEqual(KS.Reactor.ksQuaternion,KS.Reactor.ksQuaternion)">
            Check if two ksQuaternions are equal.
            
            @param   ksQuaternion a
            @param   ksQuaternion b
            @return  bool
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity">
            Base class for entities. Entities are objects controlled by the server and replicated to clients.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.RPCHandler">
            RPC event handler.
            
            @param   ksMultiType[] arguments from the server.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.ControllerChangeHandler">
            Controller change handler.
            
            @param   ksPlayerController oldController
            @param   ksPlayerController newController
        </member>
        <member name="T:KS.Reactor.Client.ksBaseEntity.DestroyHandler">
            Destroy event handler.
            
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OnPropertyChange">
            Invoked when an entity property changes. Indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.OnRPC">
            Invoked when the server calls an RPC on the room. Indexed by RPC id.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnControllerChange">
            Invoked when the player controller changes.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseEntity.OnDestroy">
            Invoked when the entity is destroyed.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Id">
            Entity id
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Type">
            Entity type
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Position">
            Position
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Rotation">
            Rotation
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Scale">
            Scale
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerPosition">
            Server position
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerRotation">
            Server rotation
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerScale">
            Server scale
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Velocity">
            Velocity calculated as the displacement of the entity from the last frame to the current frame divided by the frame time.
            This is different than the instaneous velocity of the entity which is tracked in RigidBody.Velocity.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.AngularVelocity">
            Angular velocity. Component values are in degrees per second.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Position2D">
            2D position
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Rotation2D">
            2D rotation in degrees
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.RotationRadians2D">
            2D rotation in radians
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Scale2D">
            2D scale
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Velocity2D">
            2D velocity
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.AngularVelocity2D">
            2D angular velocity in degrees per second.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerPosition2D">
            Server 2D position
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerRotation2D">
            Server 2D rotation in degrees
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerRotationRadians2D">
            Server 2D rotation in radians
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.ServerScale2D">
            Server 2D scale
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Properties">
            Entity properties
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.Predictor">
            Predictor for the entity.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.RigidBody">
            The entity's rigid body. Null if the entity does not have a rigid body.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.RigidBody2D">
            The entity's 2D rigid body. Null if the entity does not have a 2D rigid body.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.CharacterController">
            Character controller.
        </member>
        <member name="F:KS.Reactor.Client.ksBaseEntity.m_playerController">
            Player controller controlling this entity.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsPermanent">
            Is this a permanent entity? Permanent entities never move and cannot be destroyed. They are not synced to
            clients since the clients should already know where they are.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.CollisionFilter">
            Determines which entities to collide with and notify of collision/overlap events.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.PropertySync">
            PropertySync
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsDestroyed">
            Is the entity destroyed?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.IsServerGhost">
            Is this a server ghost entity? Server ghosts are duplicate entities with smoothing turned off, so they show
            the last known server location.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.HasServerGhost">
            Does this entity have a server ghost? Server ghosts are duplicate entities with smoothing turned off, so they show
            the last known server location.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseEntity.BaseRoom">
            Room the entity is in.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.CleanUp">
            Cleanup the object for reuse.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Calls an RPC on this entity on the server.
            
            @param   uint rpcId of rpc to call.
            @param   ksMultiType[] arguments to send to server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InitializeScripts">
            Initializes entity scripts.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.Destroy(System.Boolean)">
            Destroys the entity.
            
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.ResolvePenetration(KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion)">
            Resolves penetrations resulting from moving between two points.
            
            @param   ksVector3 from - start position.
            @param   ksVector3 to - end position.
            @param   ksQuaternion rotation.
            @return  ksVector3 position between start and end points before penetration occurred, 
                     or end position if no penetration occurred.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.Sweep(KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3@,KS.Reactor.ksVector3@)">
            Checks if the entity will collide with anything when moving between two points.
            
            @param   ksVector3 from - position to sweep from.
            @oaram   KSVector to - position to sweep to.
            @param   ksQuaternion rotation
            @param   out ksVector3 position of the entity at the end of the sweep. If a collision occurred, this is
                     the entity's position when it happened.
            @param   out ksVector3 normal of collision surface.
            @return  bool true if a collision occured.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.BecomeServerGhost">
            Indicate this is a server ghost. Server ghosts are duplicate entities used for debugging
            with no movement smoothing so they are always rendered at the last server position. 
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.SetVisible(System.Boolean)">
            Hides or shows the entity. This is used to hide server ghosts when the entity is idle.
            
            @param   bool visible - true if the entity should be visible.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Invoke managed RPCs on all entity scripts.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.SetPropertySync(KS.Reactor.Client.PropertySync,System.Boolean)">
            Sets the property sync.
            
            @param   PropertySync sync to set.
            @param   bool mergeWithExisting - if true, will copy the property change handlers and prediction behaviours
                     from the old property sync into the new one.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.InvokeDestroy(System.Boolean)">
            Invokes the on destroy event.
            
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.ExecuteRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Invokes an OnRPC event.
            
            @param   uint rpcID of rpc to invoke.
            @param   ksMultiType[] arguments from the server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.RegisterRPC(System.UInt32,KS.Reactor.Client.ksBaseEntity.RPCHandler)">
            Register an RPC
            
            @param   uint RPC Id
            @param   ksServerEvents.RPCHandler RPC handler
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.UnregisterRPC(System.UInt32,KS.Reactor.Client.ksBaseEntity.RPCHandler)">
            Unregister an RPC
            
            @param   uint RPC Id
            @param   ksServerEvents.RPCHandler RPC handler
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.SetPredictionBehaviour(System.UInt32,KS.Reactor.Client.ksPredictionBehaviour)">
            Set the prediction behaviour of a property.
            
            @param   uint property Id
            @param   ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.GetPredictionBehaviour(System.UInt32)">
            Gets prediction behaviour of a property.
            
            @param   uint property Id
            @return  ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.GetPropertyServerValue(System.UInt32)">
            Gets property server value. If a property id is not in the map, 
            a ksMultiType of type ksMultiType.Types.UNDEFINED is returned.
            
            @param   uint propertyId
            @return  ksMultiType
        </member>
        <member name="M:KS.Reactor.Client.ksBaseEntity.ShowServerGhost(System.Boolean)">
            Shows or hides a server ghost for this entity. The server ghost is a duplicate entity with smoothing
            disabled, so it renders as the last know server location. Server ghosts are tinted green. Note that server
            ghosts will have all the same scripts as the real object, but no colliders. Your scripts can check if they
            are attached to a ghost using Entity.IsServerGhost. Calling this function or RPCs on ghost entities has no
            effect.
            
            @param   bool show - true to create a server ghost. false to destroy it.
        </member>
        <member name="T:KS.Reactor.Client.ksBasePlayer">
            Base class for players. A player represents a client.
        </member>
        <member name="T:KS.Reactor.Client.ksBasePlayer.LeaveHandler">
            Leave event handler.
        </member>
        <member name="E:KS.Reactor.Client.ksBasePlayer.OnLeave">
            Invoked when the (non-local) player leaves the room.
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.OnPropertyChange">
            Invoked when a player property changes. Indexed by property id.
        </member>
        <member name="F:KS.Reactor.Client.ksBasePlayer.m_propertySync">
            Property sync
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.Properties">
            Properties
        </member>
        <member name="F:KS.Reactor.Client.ksBasePlayer.m_isLocal">
            Is this the local player?
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.Id">
            Id of the player.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.#ctor(System.UInt32)">
            Constructor
            
            @param   uint id of the player.
        </member>
        <member name="P:KS.Reactor.Client.ksBasePlayer.BaseRoom">
            Room the player is in.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.InitializeScripts">
            Initializes player scripts.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.Destroy">
            Destroys the player.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.InvokeOnLeave">
            Invokes the OnLeave event.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.SyncProperties">
            Syncs player properties with the server.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.SetPredictionBehaviour(System.UInt32,KS.Reactor.Client.ksPredictionBehaviour)">
            Set the prediction behaviour of a property.
            
            @param   uint property Id
            @param   ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.GetPredictionBehaviour(System.UInt32)">
            Gets prediction behaviour of a property.
            
            @param   uint property Id
            @return  ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBasePlayer.GetPropertyServerValue(System.UInt32)">
            Gets property server value. If a property id is not in the map, 
            a ksMultiType of type ksMultiType.Types.UNDEFINED is returned.
            
            @param   uint propertyId
            @return  ksMultiType
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom">
            Base class for rooms. Rooms are used to connect to server rooms.
            The room maintains simulation state that is regularly synced with the server.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectionStates">
            Connection states
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectError">
            Connection success/failure reasons
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.DisconnectError">
            Diconnection reasons
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectEvent">
            Information about a connection event
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.DisconnectEvent">
            Information about a disconnection event
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.StateChangeHandler">
            Handler called when the room connection state changes.
            
            @param   ksBaseRoom - Room whose state changed
            @param   ConnectionStates - New room status
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.ConnectHandler">
            Connect status event handler. 
            
            @param   ConnectStatus status of the connection.
            @param   uint custom status id (0 = no error, UInt32.MaxValue = Unknown Authentication Error)
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.DisconnectHandler">
            Disconnect status event handler. 
            
            @param   ConnectStatus status of the connection.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom.RPCHandler">
            RPC event handler.
            
            @param   ksMultiType[] arguments from the server.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom.OnStateChange">
            Events called when the connection state changes.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.ConnectionState">
            Get the connection state of the room. 
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Id">
            Room id
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Info">
            Room info
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Time">
            Server time and local frame delta.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Physics">
            Physics interface
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsConnecting">
            Are we in the process of establishing a connection with the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsConnected">
            Are we connected to the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsDisconnecting">
            Are we disconnecting from the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.SuppressCannotCallRPCWarning">
            Should we suppress "Cannot call RPC" warnings when disconnected or disconnecting?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.LocalPlayerId">
            The local player id.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.PredictorFactory">
            ksIPredictor factory
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.InputAcknowledged">
            Has the server acknowledged receiving our first input?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.UpdateObjectsEveryServerFrame">
            Do we need to call SyncObject.UpdateServerState after every server frame? Set this to true if you aren't
            using a predictor factory and your compressor utility needs to process all server frames.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.InputRegistrar">
            Input registrar
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Input">
            Input
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.PlayerControllerFactory">
            Player controller factory
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.PropertySync">
            Property sync
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Gravity">
            Gravity
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ApplyServerTimeScale(System.Single)">
            Apply server time scale to the client.
            
            @param   float timeScale
            @return  bool - true if time scaling was applied to the system that generates delta times used during updates.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.RPCLatency">
            RPC Latency in milliseconds
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.Latency">
            Latency in milliseconds
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.ServerEvents">
            Server Event list
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.RoomUpdates">
            Server frames
        </member>
        <member name="F:KS.Reactor.Client.ksBaseRoom.m_connectionFactories">
            Connection factories
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.GetTimeAdjuster``1">
            Gets the first ksITimeAdjuster of the type T, or null if none is found.
            
            @return  T time adjuster.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Connect(KS.Reactor.Client.ksPlayerControllerFactory,KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            Connects to the server.
            
            @param   ksPlayerControllerFactory - factory for creating player controllers.
            @param   ksPlayerAPI.Session - player session
            @param   ksMultiType[] - authentication arguments
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Disconnect(System.Boolean)">
            Disconnects from the server.
            
            @param   bool immediate - if false, waits for pending writes before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DiagnoseConnectionFailure">
            Diagnose Connection Failure to the server.
            
            @return  string - error message
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.Update(System.Single,System.Single)">
            Updates the room. Syncs properties from the server and updates scripts.
            
            @param   float deltaTime since the last update in seconds of game time.
            @param   float realDeltaTime since last update in seconds of real time.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.CallEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[])">
            Calls an entity function on the server. Does nothing if not connected to the server.
            
            @param   uint entityId of entity to call rpc on.
            @param   uint rpcId of function to call on server.
            @param   ksMultiType[] arguments to send to server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.GetObject(System.UInt32)">
            Gets an object by id.
            
            @param   uint objectId
            @return  SyncObject
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.SpawnServerGhost(System.UInt32)">
            Spawns a server ghost object.
            
            @param   uint objectId of object to create ghost for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DestroyServerGhost(System.UInt32)">
            Destroys a server ghost object.
            
            @param   uint objectId of object to destroy ghost for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AddControlledEntity(KS.Reactor.Client.ksBaseEntity)">
            Adds an entity to the list of controlled entities.
            
            @param   Entity entity to add.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.RemoveControlledEntity(KS.Reactor.Client.ksBaseEntity)">
            Removes an entity from the list of controlled entities.
            
            @param   Entity entity to remove.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.PushTime(System.UInt64,System.Single,System.UInt64)">
            Pushes a time update.
            
            @param   ulong serverTime - Total amount of simulated server time in microseconds.
            @param   ulong serverDeltaTime - Amount of simulated server time between sync frames in seconds.
            @param   ulong frame - server frame number.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.AcknowledgeInput(System.Int32)">
            Decrements the pending input acknowlegement counter.
            
            @param   int numAcknowlegements - amount to decrement by.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.FindOrCreatePlayer(System.UInt32,KS.Reactor.Client.ksBasePlayer@)">
            Find an existing ksBasePlayer or create a new one
            
            @param   uint player id
            @param   out ksBasePlayer
            @return  bool true if a new player was created
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.FindOrCreateSyncObject(System.UInt32,KS.Reactor.Client.SyncObject@,System.Boolean)">
            Find an existing SyncObject or create a new one
            
            @param   uint sync object id
            @param   out SyncObject
            @param   bool create a new sync object if an existing one was not found (Default = true)
            @return  bool true if a new sync object was created
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom.GetAllSyncObjects" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom.ActivatePlayer(System.UInt32)">
            Move new player to the active player list and load scripts.
            
            @param   uint player id
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.InvokePlayerJoin(System.UInt32)">
            Invokes the on player join event, and initializes scripts on the player.
            
            @param   uint player id of player to invoke event for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ActivateSyncObject(KS.Reactor.Client.SyncObject)">
            Move new sync object to the active sync object list, initialize properties and fire an entity spawn event.
            
            @param   uint sync object id
            @return  bool true if the syncObject was succesfully activated.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DestroyPlayer(System.UInt32)">
            Remove a player from the room and fire a player disconnect event.
            
            @param   uint player id
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.DestroySyncObject(System.UInt32,System.Boolean)">
            Remove a sync object (and entity) from the room and fire a entity destroy event.
            
            @param   uint sync object id
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ExecuteRoomRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Execute an RPC on the room
            
            @param   uint RPC id
            @param   ksMultiType[] RPC arguments
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.ExecuteEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[])">
            Execute an RPC on an entity.
            
            @param   uint entityId
            @param   uint RPC id
            @param   ksMultiType[] RPC arguments
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom.UpdateEntityProperties(System.UInt32,System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[],System.UInt64)" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom.RegisterConnectionFactory(KS.Reactor.Client.ksConnection.Protocols,KS.Reactor.Client.ksConnection.Factory)">
            Add a connection factory for a protocol.
            If a null factory is provided, then any existing factory with that protocol is removed.
            
            @param   Protocol connection protocol
            @param   ConnectionFactory connection factory
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IsIdle">
            Is the connection idle?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom.IdleTime">
            Amount of time the player has been idle. Negative if the player is not idle.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom.RemoveSyncGroups(System.Collections.Generic.HashSet{System.UInt32})" -->
        <member name="P:KS.Reactor.Client.ksBaseRoom.Protocol">
            Get / Set the connection protocol used for new connections.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Invoke managed RPCs on all room scripts.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2">
            Templated base class for rooms. Rooms are used to connect to server rooms.
            The room maintains simulation state that is regularly synced with the server.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.PlayerJoinHandler">
            Player join event handler.
            
            @param   Player player who joined the room.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.PlayerLeaveHandler">
            Player leave event handler.
            
            @param   Player player who left the room.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.SpawnEntityHandler">
            Spawn entity event handler.
            
            @param   Entity entity that was spawned.
        </member>
        <member name="T:KS.Reactor.Client.ksBaseRoom`2.DestroyEntityHandler">
            Destroy entity event handler.
            
            @param   Entity entity that was destroyed.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnConnect">
            Invoked when the room is connected
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnDisconnect">
            Invoked when the room is disconnected
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnPlayerJoin">
            Invoked when a player joins the room.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnPlayerLeave">
            Invoked when a (non-local) player leaves the room.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnSpawnEntity">
            Invoked when an entity is spawned.
        </member>
        <member name="E:KS.Reactor.Client.ksBaseRoom`2.OnDestroyEntity">
            Invoked when an entity is destroyed.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.OnPropertyChange">
            Invoked when a room property changes. Indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.OnRPC">
            Invoked when the server calls an RPC on the room. Indexed by RPC id.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Coroutines">
            Coroutines 
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Info">
            Room Info
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Time">
            Server time and local frame delta.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Properties">
            Properties
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.TimeAdjusters">
            The list of time adjusters that calculate Time.AdjustedDelta to try keep time in sync with the server.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsConnecting">
            Are we in the process of establishing a connection with the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsConnected">
            Are we connected to the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsDisconnecting">
            Are we disconnecting from the server?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.SuppressCannotCallRPCWarning">
            Should we suppress "Cannot call RPC" warnings when disconnected or disconnecting?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.LocalPlayer">
            The local player. This will be null until we've received an update from the server.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Players">
            List of players connected to the room.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetPlayer(System.UInt32)">
            Get player by id.
            
            @param   uint id
            @return  Player
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Entities">
            List of entities in the room.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.ServerGhostEntities">
            List of server ghost entities in the room.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.ControlledEntities">
            List of entities controlled by the local player (entities with player controllers).
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.LocalPlayerId">
            The local player id.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PredictorFactory">
            ksIPredictor factory
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputAcknowledged">
            Has the server acknowledged receiving our first input?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputInterval">
            The interval in seconds at which input frames are generated and sent to the server. An input frame is a
            collection of button and axes states represented by ksInput. If set to zero, sends one input frame for every
            client frame. If less than zero, input frames are not sent automatically and must be sent by calling
            SendInput.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.SendUnchangedInput">
            If true, sends all input frames to the server. If false, only sends input frames to the server when the
            input changed since the last frame. Unless you are using a custom ksIInputProcessor that requires every
            input frame to be sent, there is no reason to set this to true.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.MultiButtonStateEnabled">
            If true and multiple input updates are combined into one input frame, a button can be both pressed and
            released in the same frame if it's up/down state changed multiple times in the same frame. If false, the
            up/down state of a button can only change once in one input frame.
            
            If InputInterval is zero so one input frame is generated for every client frame, this has no effect.
            
            Eg. Three client frames are combined into one input frame. The button is up on the first frame, down on the
            second, and up again on the third. If MultiButtonStateEnabled is true, this produces one input frame
            where Input.IsDown returns false, and Input.IsPressed and Input.IsReleased return true. If
            MultiButtonStateEnabled is false, this produces one input frame where Input.IsDown and Input.IsPressed
            return true and Input.IsReleased returns false. If the button up/down state does not change again during
            the next input frame, Input.IsDown will return false and Input.IsReleased will return true on the next
            input frame.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.UpdateObjectsEveryServerFrame">
            Do we need to call SyncObject.UpdateServerState after every server frame? Set this to true if you aren't
            using a predictor factory and your compressor utility needs to process all server frames.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PropertySync">
            Property sync
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.InputRegistrar">
            Input registrar
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Input">
            Input
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.PlayerControllerFactory">
            Player controller factory
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.RPCLatency">
            Round trip latency measured with RPC calls.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Latency">
            Round trip latency measured with the connection protocol.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.ReadProgress">
            Get the size and progress of the current connection read operation.
            @return  ksFrameInfo 
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.WriteProgress">
            Get the size and progress of the current connection write operation.
            @return  ksFrameInfo 
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.#ctor(KS.Reactor.ksRoomInfo)">
            Constructor
            
            @param   ksRoomInfo roomInfo determines where we connect.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetEntity(System.UInt32)">
            Gets the entity in this room with the given id.
            
            @param   uint entityId of entity to get.
            @return  Entity with the given id, or null if no entity with that id was found.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetServerGhostEntity(System.UInt32)">
            Gets the server ghost entity in this room with the given id.
            
            @param   uint entityId of entity to get.
            @return  Entity
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetTimeAdjuster``1">
            Gets the first ksITimeAdjuster of the type T, or null if none is found.
            
            @return  T time adjuster.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CreatePredictor(KS.Reactor.Client.ksBaseEntity)">
            Creates a predictor for an entity or player/room properties.
            
            @param   ksBaseEntity entity to get predictor for. Null if predicting player/room properties.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddTimeAdjuster(KS.Reactor.Client.ksITimeAdjuster)">
            Adds a ksITimeAdjuster to the room. This cannot be called on a connected room.
            
            @param   ksITimeAdjuster timeAdjuster to add.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveTimeAdjuster(KS.Reactor.Client.ksITimeAdjuster)">
            Removes a ksITimeAdjuster from the room. This cannot be called on a connected room.
            
            @param   ksITimeAdjuster timeAdjuster to remove.
            @return  bool true if the time adjuster was found and removed.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveTimeAdjuster``1">
            Removes the first ksITimeAdjuster of the type T. This cannot be called on a connected room.
            
            @return  bool true if a time adjuster of type T was found and removed.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ClearTimeAdjusters">
            Removes all time adjusters. This cannot be called on a connected room.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CanModifyTimeAdjusters">
            Logs a warning and returns false if the room is connected.
            
            @return  bool true if the room is not connected.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SendInput(System.Boolean,System.Single)">
            Generates an input frame to send to the server, and calls InputUpdate on predictors for entities with player
            controllers.
            
            @param   forceUpdate - if false, will only send a new input frame to server if there were input changes
                     since the last frame.
            @param   float deltaTime - the time step to use when calling InputUpdate on predictors. If less than zero, the
                     time deltas are unchanged. Otherwise, they are set to the following:
                         Time.RealDelta = deltaTime
                         Time.Delta = deltaTime * Time.ServerTimeScale
                         Time.AdjustedDelta = Time.AdjustedDelta * (deltaTime / Time.RealDelta)
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CleanUp">
            Destroys all entities and players in the room. Call this after disconnecting. If called
            while connected, does nothing.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.Equals(KS.Reactor.Client.ksBaseRoom)" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CreatePlayer(System.UInt32)">
            Creates a player.
            
            @param   uint id of player.
            @return  Player
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CreateEntity(System.UInt32,System.UInt32,System.Boolean)">
            Creates an entity.
            
            @param   uint id of entity.
            @param   uint type of entity.
            @param   bool isGhost - if true, we are creating an entity for a server ghost
            @return  Entity
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.LoadPermanentEntities" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.LoadPlayerScripts(`0)">
            Loads and attaches player scripts to a player.
            
            @param   Player player to attach scripts to.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InitializeScripts">
            Initializes room scripts.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateScripts">
            Updates scripts.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Connect(KS.Reactor.Client.ksPlayerControllerFactory,KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            Connects to the server.
            
            @param   ksPlayerControllerFactory - factory for creating player controllers.
            @param   ksPlayerAPI.Session - player session
            @param   ksMultiType[] - authentication arguments
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Disconnect(System.Boolean)">
            Disconnects from the server.
            
            @param   bool immediate - if false, waits for pending writes before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SocketErrorToConnectStatus(System.Net.Sockets.SocketError)">
            Convert a socket error to room connect error.
            
            @param   SocketError error
            @return   ConnectError
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleConnect(KS.Reactor.Client.ksConnection,System.Net.Sockets.SocketError,System.Object)">
            Handle a connection completed event.
            
            @param   Connection - connection
            @param   SocketError - connection result (If the connection was successful this value will be SocketError.Success)
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleDisconnect(KS.Reactor.Client.ksConnection,System.Net.Sockets.SocketError)">
            Handle a connection disconnect event.
            
            @param   Connection - connection
            @param   SocketError - connection result
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SentPacket(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            Release the sent packet buffer.
            
            @param   Connection - connection that is calling the handler
            @param   ksStreamBuffer - buffer that was written to the connection.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveHandshake(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            Handle a handshake packet.
            Decodes a the handshake packet and writes a model validation packet to the connection.
            
            @param   Connection - connection that is calling the handler
            @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveValidateModel(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            Handle a modelvalidation packet.
            Decodes the validate model packet and writes an authentication packet to the connection.
            
            @param   Connection - connection that is calling the handler
            @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveAuthentication(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
            Handle an authentication packet.
            Decodes the authentication packet and updates the connection state.
            
            @param   Connection - connection that is calling the handler
            @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveFrame(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
             Handle a frame packet.
            
             @param   Connection - connection that is calling the handler
             @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceiveIdle(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
             Handle an idle packet.
            
             @param   Connection - connection that is calling the handler
             @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ReceivePong(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer)">
             Handles the reception of a pong packet.
             Decodes the packet and updates the connection latency.
            
             @param   Connection - connection that is calling the handler
             @param   ksStreamBuffer - buffer containing the packet header and body
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SetConnectEvent(KS.Reactor.Client.ksBaseRoom.ConnectError,System.UInt32)">
            Creates a new connect event if one does not already exist.
            
            @param   ConnectError - Connection error state
            @param   uint - Custom status code defined by the game developer
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SetDisconnectEvent(KS.Reactor.Client.ksBaseRoom.DisconnectError)">
            Creates a new disconnect event if one does not already exist.
            
            @param   DisconnectError - Disconnection error state
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleConnectionEvents">
            Calls the connect handler if the connection event is set.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DiagnoseConnectionFailure">
            Diagnose Connection Failure to the server.
            
            @return String error message
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.Update(System.Single,System.Single)">
            Updates the room. Syncs properties from the server and updates scripts.
            
            @param   float deltaTime since the last update in seconds of game time.
            @param   float realDeltaTime since last update in seconds of real time.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ProcessServerFrame">
            Processes an update from the server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AcknowledgeInput(System.Int32)">
            Decrements the pending input acknowlegement counter.
            
            @param   int numAcknowlegements - amount to decrement by.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Calls a function on the server. Does nothing if not connected to the server.
            
            @param   uint rpcId of function to call on server.
            @param   ksMultiType[] arguments to send to server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CallEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[])">
            Calls an entity function on the server. Does nothing if not connected to the server.
            
            @param   uint entityId of entity to call rpc on.
            @param   uint rpcId of function to call on server.
            @param   ksMultiType[] arguments to send to server.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.CallBatchRPC(System.Collections.Generic.IEnumerable{`1},System.UInt32,KS.Reactor.ksMultiType[])" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetObject(System.UInt32)">
            Gets an object by id.
            
            @param   uint objectId
            @return  SyncObject
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.PushTime(System.UInt64,System.Single,System.UInt64)">
            Pushes a time update.
            
            @param   ulong serverTime - Total amount of simulated server time in microseconds.
            @param   ulong serverDeltaTime - Amount of simulated server time between sync frames in seconds.
            @param   ulong frame - server frame number.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.CanCallRPC">
            Checks if we can call an RPC by checking if we are connected and not disconnecting. Logs a warning if we
            cannot.
            
            @param   bool true if we can call an RPC.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SyncProperties">
            Syncs room properties with the server.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SyncTime(System.Single,System.Single)">
            Syncs time with the server.
            
            @param   float deltaTime since the last update in seconds of game time.
            @param   float realDeltaTime since last update in seconds of real time.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SpawnEntity(KS.Reactor.Client.SyncObject)">
            Spawns an entity.
            
            @param    SyncObject syncObject the entity is for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SpawnServerGhost(KS.Reactor.Client.SyncObject)">
            Spawns a server ghost object.
            
            @param   SyncObject syncObject to create ghost for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SpawnServerGhost(System.UInt32)">
            Spawns a server ghost object.
            
            @param   uint objectId of object to create ghost for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DestroyServerGhost(System.UInt32)">
            Destroys a server ghost object.
            
            @param   uint objectId of object to destroy ghost for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.AddControlledEntity(KS.Reactor.Client.ksBaseEntity)">
            Adds an entity to the list of controlled entities.
            
            @param   Entity entity to add.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RemoveControlledEntity(KS.Reactor.Client.ksBaseEntity)">
            Removes an entity from the list of controlled entities.
            
            @param   Entity entity to remove.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.FindOrCreatePlayer(System.UInt32,KS.Reactor.Client.ksBasePlayer@)">
            Find an existing ksBasePlayer or create a new one
            
            @param   uint player id
            @param   out ksBasePlayer
            @return  bool true if a new player was created
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.FindOrCreateSyncObject(System.UInt32,KS.Reactor.Client.SyncObject@,System.Boolean)">
            Find an existing SyncObject or create a new one
            
            @param   uint sync object id
            @param   out SyncObject
            @param   bool create a new sync object if an existing one was not found (Default = true)
            @return  bool true if a new sync object was created
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.GetAllSyncObjects" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ActivatePlayer(System.UInt32)">
            Move new player to the active player list, initialize properties and scripts.
            
            @param   uint player id
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.InvokePlayerJoin(System.UInt32)">
            Invokes the on player join event, and initializes scripts on the player.
            
            @param   uint player id of player to invoke event for.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ActivateSyncObject(KS.Reactor.Client.SyncObject)">
            Move new sync object to the active sync object list, initialize properties and fire an entity spawn event.
            
            @param   SyncObject syncobject
            @return  bool true if the sync object was activated succesfully.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DestroyPlayer(System.UInt32)">
            Remove a player from the room and fire a player leave event.
            
            @param   uint player id
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.DestroySyncObject(System.UInt32,System.Boolean)">
            Remove a sync object (and entity) from the room and fire a entity destroy event.
            
            @param   uint - sync object id
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ExecuteRoomRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Execute an RPC on the room.
            
            @param   uint RPC id
            @param   ksMultiType[] RPC arguments
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ExecuteEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[])">
            Execute an RPC on an entity.
            
            @param   uint entityId
            @param   uint RPC id
            @param   ksMultiType[] RPC arguments
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.UpdateEntityProperties(System.UInt32,System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[],System.UInt64)" -->
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.RegisterRPC(System.UInt32,KS.Reactor.Client.ksBaseRoom.RPCHandler)">
            Register an RPC
            
            @param   uint RPC Id
            @param   ksServerEvents.RPCHandler RPC handler
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UnregisterRPC(System.UInt32,KS.Reactor.Client.ksBaseRoom.RPCHandler)">
            Unregister an RPC
            
            @param   uint RPC Id
            @param   ksServerEvents.RPCHandler RPC handler
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SendPing(System.Single)">
            Send ping requests to the server.
            
            @param   float - Time between update frames.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.UpdateLatency(System.Byte,System.Int64,System.Int64[],System.Int32@,System.Int32@)">
            Update latency with new netowrk and RPC ping times.
            
            @param   byte - Ping type (0 = network, 1 = RPC)
            @param   long - ping send time
            @param   long[] - ping history
            @param   ref int - current ping index in the history array
            @param   ref int - latency value to update
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.SetPredictionBehaviour(System.UInt32,KS.Reactor.Client.ksPredictionBehaviour)">
            Set the prediction behaviour of a property.
            
            @param   uint property Id
            @param   ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetPredictionBehaviour(System.UInt32)">
            Gets prediction behaviour of a property.
            
            @param   uint property Id
            @return  ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.GetPropertyServerValue(System.UInt32)">
            Gets property server value. If a property id is not in the map, 
            a ksMultiType of type ksMultiType.Types.UNDEFINED is returned.
            
            @param   uint propertyId
            @return  ksMultiType
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.HandleIdle">
            When becoming idle we destroy all sync objects to avoid prediction extrapolation and because 
            the first frame after disabling idle will be a full sync frame which will create the objects.
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IsIdle">
            Is the connection idle?
        </member>
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.IdleTime">
            Amount of time the player has been idle. Negative if the player is not idle.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksBaseRoom`2.RemoveSyncGroups(System.Collections.Generic.HashSet{System.UInt32})" -->
        <member name="P:KS.Reactor.Client.ksBaseRoom`2.Protocol">
            Get/Set the network protocol to use for connections.
        </member>
        <member name="M:KS.Reactor.Client.ksBaseRoom`2.ToString">
            Returns a string containing the room id, room type, and scene name.
            
            @return  string containing the room id, room type, and scene name.
        </member>
        <member name="T:KS.Reactor.Client.ksClientInputPredictor">
            <summary>Predicts movement and properties using only the player controller; server data is ignored.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksClientInputPredictor.RequiresController">
            <summary>Always true; the client input predictor requires a player controller.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.Create">
            <summary>Gets a client input predictor instance from the pool, or creates one if the pool is empty.</summary>
            <returns>Predictor instance</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.#ctor">
            <summary>Private constructor. Forces use of object pooling via <see cref="M:KS.Reactor.Client.ksClientInputPredictor.Create"/>.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.CleanUp">
            <summary>Resets member variables and return the LinearPredictor to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.AddProperty(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Initializes smoothing for a property. Called once per property that will be smoothed.</summary>
            <param name="propertyId">Id of property that will be smoothed.</param>
            <param name="value">Property value.</param>
            <param name="smoothingData">Smoothing data for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.ServerUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">
            Server transform and velocity data. Velocity data is currently not synced and is always zero.
            </param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.ClientUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform and velocity to update with new values.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksClientInputPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="T:KS.Reactor.Client.ksClientTime">
            Holds time data that is available on the client.
        </member>
        <member name="F:KS.Reactor.Client.ksClientTime.m_zero">
            Time with zero for all values.
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.AdjustedDelta">
            Local game time in seconds since the last update, adjusted by ksITimeAjusters to try stay in sync with the
            server.
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerTime">
            Simulated server time in seconds.
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerDelta">
            Amount of time simulated on the server since the previous server frame.
        </member>
        <member name="P:KS.Reactor.Client.ksClientTime.ServerTimeScale">
            Average time scaling applied over all server frames processed in the last room update.
        </member>
        <member name="T:KS.Reactor.Client.ksConnection">
            Base class for network connections.
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.Protocols">
            Supported network protocols
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.ConnectOperation">
            Track connect operations
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.ConnectOperation.#ctor(KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            Constructor.
            
            @param   ConnectHandler - Callback to invoke when the connection attempt succeeds or fails
            @param   object - Aysnc state object
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.IOOperation">
            Track read/write operations
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.IOOperation.#ctor(System.Net.Sockets.SocketAsyncOperation,KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            Constructor.
            
            @param   SocketAsyncOperation - Type of socket operation
            @param   ksStreamBuffer.Segment - Stream buffer segment to operate on
            @param   IOHandler - Callback to invoke when the operation completes
            @param   object - Async state object
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.Factory">
            Method to generate connections.
            
            @return  ksConnection
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.ConnectHandler">
            Handler called when connection attempts complete.
            
            @param   ksConnection - connection that is calling the handler
            @param   SocketError - connection result (If the connection was successful this value will be SocketError.Success)
            @param   object - asynchronous state
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.DisconnectHandler">
            Handler called when connection disconnects.
            
            @param   ksConnection - connection that is calling the handler
            @param   SocketError - connection result
        </member>
        <member name="T:KS.Reactor.Client.ksConnection.IOHandler">
            Handler called when a read/write operation completes.
            
            @param   ksConnection - connection that is calling the handler
            @param   ksStreamBuffer.Segment - buffer segment that was read from or written to
            @param   SocketError - operation result
            @param   object - asynchronous state
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.Address">
            Return the host and port as a single address string.
            
            @return  string
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.ReadProgress">
            Get the progress of the current read operation.
            
            @return  ksFrameInfo
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.WriteProgress">
            Get the progress of the current write operation.
            
            @return  ksFrameInfo
        </member>
        <member name="P:KS.Reactor.Client.ksConnection.IsConnected">
            Check if a connection to the server is open.
            
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Connect(System.String,System.UInt16,KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            Establish a connection to a server.
            
            @param   string - server host name
            @param   ushort - server port
            @param   ConnectHandler - callback to invoke when the connection attempt completes
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Disconnect(System.Boolean)">
            Disconnect from the server.
            
            @param   bool - immediate. If this is false, then queued write operations will complete before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Read(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            Read data from the connection into a stream buffer segment.
            
            @param   ksStreamBuffer.Segment - segment of a larger stream buffer
            @param   IOHandler - callback to invoke when the read operation completes
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksConnection.Write(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            Read data from the connection into a stream buffer segment.
            
            @param   ksStreamBuffer.Segment - segment of a larger stream buffer
            @param   IOHandler - callback to invoke when the write operation completes
            @param   object - asynchronous state
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor">
            <summary>
            Predicts movement and properties based on user input using a player controller. Accelerations are slower than
            the server so the client and server will converge.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame">
            <summary>Client input frame. Contains input and delta time.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.Input">
            <summary>Input state for the frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.DeltaTime">
            <summary>Frame duration in seconds.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.InputFrame.#ctor(KS.Reactor.ksInput,System.Single)">
            <summary>Constructor</summary>
            <param name="input">Input state for the frame.</param>
            <param name="deltaTime">Frame duration in seconds.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData">
            <summary>Configuration parameters for the converging input predictor.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Default">
            <summary>Default configuration values. Values can be changed to change the defaults.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityToleranceCalculator">
            <summary>
            Calculates the velocity tolerance for an entity. Called when <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityTolerance"/> is set to
            <see cref="!:Auto"/>.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.AUTO">
            <summary>
            If <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityTolerance"/> is set to this, a velocity tolerance is automatically calculated for
            the entity by calling <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityToleranceCalculator"/> if it is not null, otherwise one is
            used as the velocity tolerance.
            </summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.ResetPropertyCallback">
            <summary>
            Property reset callback, called when a property is reset to the server state before replaying inputs
            through the player controller.
            </summary>
            <param name="value">Server property value.</param>
            <param name="changeRate">Server property change rate per second.</param>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.ConvergeMultiplier">
            <summary>Lower values mean we try to converge more aggressively.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.MaxDeltaTime">
            <summary>
            Maximum time step for the client over a single frame. If a frame's time delta is larger than this, this
            is used as the time delta instead. The predictor behaves poorly with large time steps, and limiting the
            maximum time step can improve the behaviour when there are dips in frame rate.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.DefaultLatency">
            <summary>Latency in seconds to use before latency is determined.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyPosition">
            <summary>
            If true, converging prediction is not run on the position. Instead the player controller alone
            determines the client position. Changing this after <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)"/> 
            is called does nothing.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyRotation">
            <summary>
            If true, converging prediction is not run on the rotation. Instead the player controller alone
            determines the client rotation. Changing this after <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)"/> 
            is called does nothing.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.UseClientOnlyScale">
            <summary>
            If true, converging prediction is not run on the scale. Instead the player controller alone determines
            the client scale. Changing this after <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)"/> is called does
            nothing.
            </summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityTolerance">
            <summary>
            Maximum difference between client and server velocity before inputs are replayed. Less than or equal to
            zero for no limit. If set to <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.AUTO"/>, a velocity tolerance is calculated for the entity by
            <see cref="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.VelocityToleranceCalculator"/> if it is not null, otherwise one is used.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.PositionResetCallback">
            <summary>Called before replaying inputs with new position and velocity values.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.AngularVelocityTolerance">
            <summary>
            Maximum difference between client and server angular velocity before inputs are replayed. Less than or
            equal to zero for no limit.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.RotationResetCallback">
            <summary>Called before replaying inputs with new rotation and angular velocity values.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.GetPropertyChangeTolerance(System.UInt32)">
            <summary>
            Gets the maximum difference between client and server change rates for a property before inputs are
            replayed. Zero for no limit.
            </summary>
            <param name="propertyId">Id of property to get change rate tolerance for.</param>
            <returns>Change rate tolerance for the property.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.SetPropertyChangeTolerance(System.UInt32,System.Single)">
            <summary>
            Sets the maximum difference between client and server change rates for a property before inputs are
            Replayed. Less than or equal to zero for no limit.
            - For ksVector2 properties using spherical smoothing, difference is defined as
              sqrt(deltaDegrees^2 + 90 * deltaMagnitude^2)
            - For ksVector3 properties using spherical smoothing, difference is defined as
              sqrt(deltaAngularDegrees.Magnitude()^2 + 90 * deltaMagnitude^2)
            </summary>
            <param name="propertyId">Id of property to set tolerance for.</param>
            <param name="tolerance">Tolerance to set. Less than or equal to zero for no limit.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.SetPropertyResetCallback(System.UInt32,KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.ResetPropertyCallback)">
            <summary>
            Sets the callback to call before replaying inputs with new value and change rate for a property.
            </summary>
            <param name="propertyId">Id of property to set callback for.</param>
            <param name="callback">Callback to set.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Clone">
            <summary>Creates a copy of this <see cref="T:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData"/>.</summary>
            <returns>Copy of the config.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.CallResetPropertyCallback(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.ksMultiType)">
            <summary>Calls a reset property callback.</summary>
            <param name="propertyId">Id of property to call callback for.</param>
            <param name="value">Property value</param>
            <param name="changeRate">
            Property change rate.
             - For ksVector2 properties using spherical smoothing, this is a ksVector2 where X is delta radians
               and Y is delta magnitude.
             - For ksVector3 properties using spherical smoothing, this is a float array of size 4 where the
               first 3 elements are angular velocity X, Y, Z in radians, and the 4th is delta magnitude.
            </param>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Config">
            <summary>
            Configurable data for customizing the the predictor. Returns null if the predictor is using the
            <see cref="P:KS.Reactor.Client.ksConvergingInputPredictor.ConfigData.Default"/>. Assign this if you want to override the defaults.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.RequiresController">
            <summary>Always true; the converging input predictor requires a player controller.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Create">
            <summary>
            Gets a converging input predictor instance from the pool, or creates one if the pool is empty.
            </summary>
            <returns>Predictor instance</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.#ctor">
            <summary>Private constructor. Forces use of object pooling via <see cref="M:KS.Reactor.Client.ksConvergingInputPredictor.Create"/>.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.CleanUp">
            <summary>Resets member variables and return the LinearPredictor to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.AddProperty(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Initializes smoothing for a property. Called once per property that will be smoothed.</summary>
            <param name="propertyId">Id of property that will be smoothed.</param>
            <param name="value">Property value.</param>
            <param name="smoothingData">Smoothing data for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ServerUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">
            Server transform and velocity data. Velocity data is currently not synced and is always zero.
            </param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ClientUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">Client transform and velocity to update with new values.</param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ProcessInput(KS.Reactor.Client.ksConvergingInputPredictor.InputFrame)">
            <summary>
            Updates the controller with a frame of input. Extrapolates predictions based on the controller state.
            </summary>
            <param name="frame">Input frame</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.CompareChangeRates(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>
            Calculates property change rates from server values and compares them with client values. Does not
            calculate change rates for properties with no change tolerance.
            </summary>
            <param name="state">Server physics state.</param>
            <param name="properties">Server properties whose values changed since the last frame.</param>
            <returns>
            True if the difference in change rate between client and server values for a property exceeded
            the tolerance.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ReplayInputs(KS.Reactor.Client.ksPhysicsState)">
            <summary>
            Resets property state to server values and replays inputs through the player controller to get a new
            predicted state.
            </summary>
            <param name="state">Server state.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.IterateSmoothers">
            <summary>Iterates the smoothers.</summary>
            <returns>Iterator</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother">
            <summary>Interface for smoothly predicting a ksMultiType.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.CleanUp">
            <summary>Reset member variables and return the smoother to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Advance">
            <summary>Removes the oldest history frame.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Advance(System.Single)">
            <summary>Advances through the history.</summary>
            <param name="t">Time to advance between 0 and 1 where 1 is the entirety of the oldest history frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.ClearHistory">
            <summary>Clears the history.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.GetServerChangeRate">
            <summary>Gets the server change rate.</summary>
            <returns>Server change rate.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.GetServerValue">
            <summary>Gets the server value.</summary>
            <returns>Server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the server value.</summary>
            <param name="value">Server value.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.PredictServerValue">
            <summary>Predicts the server's current value by adding the deltas from history to the last known server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.GetPredictedServerValue">
            <returns>Predicted server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Idle">
            <summary>Sets the server change rate to zero.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.CalculateChangeRate(KS.Reactor.ksMultiType,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.CompareChangeRates">
            <summary>Gets the difference between the server and client change rates.</summary>
            <returns>Difference between server and client change rates.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.AddPrediction(KS.Reactor.ksMultiType,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            @param   ksMultiType value - predicted value.
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.ExtrapolatePrediction(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.Interpolate(KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.ISmoother.ZeroFillHistory(System.Int32)">
            <summary>Adds zero filled frames of given number to history.</summary>
            <param name="num">Number of zero filled frames that need to be added to history.</param>
            @param   int number of zero filled frames that need to be added to history.
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3">
            <summary>Predicts a templated type using a templated <see cref="T:KS.Reactor.Client.ISpace`2"/>.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Create">
            <summary>Creates or fetches a smoother from the object pool.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame">
            <summary>Predicted frame</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.Delta">
            <summary>Predicted delta</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.ChangeRate">
            <summary>Predicted change rate</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Frame.#ctor(`1,`1)">
            <summary>Constructor</summary>
            <param name="delta">Predicted delta.</param>
            <param name="changeRate">Predicted change rate.</param>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ServerValue">
            <summary>Last known server value</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ServerChangeRate">
            <summary>Last known server change rate</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ClientChangeRate">
            <summary>Client change rate</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.PredictedServerValue">
            <summary>Predicted server value</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.VectorSpace">
            <summary>Vector space instance</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CleanUp">
            <summary>Resets member variables and return the smoother to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Advance">
            <summary>Removes the oldest history frame.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Advance(System.Single)">
            <summary>Advances through the history.</summary>
            <param name="t">Time to advance between 0 and 1 where 1 is the entirety of the oldest history frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ClearHistory">
            <summary>Clears the history.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.GetServerChangeRate">
            <summary>Gets the server change rate.</summary>
            <returns>Server change rate.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.GetServerValue">
            <summary>Gets the server value.</summary>
            <returns>Server value</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the server value.</summary>
            <param name="value">Server value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.PredictServerValue">
            <summary>Predicts the server's current value by adding the deltas from history to the last known server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.GetPredictedServerValue">
            <returns>ksMultiType predicted server value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Idle">
            <summary>Sets the server change rate to zero.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CalculateChangeRate(KS.Reactor.ksMultiType,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CalculateChangeRate(`0,System.Single)">
            <summary>Calculates the server change rate.</summary>
            <param name="nextValue">Next server value.</param>
            <param name="deltaTime">Server delta time.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.CompareChangeRates">
            <summary>Gets the difference between the server and client change rates.</summary>
            <returns>Difference between server and client change rates.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.AddPrediction(KS.Reactor.ksMultiType,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.AddPrediction(`0,System.Single)">
            <summary>Sets the predicted server value and adds a prediction to the history.</summary>
            <param name="value">Predicted value.</param>
            <param name="deltaTime">Delta time in seconds.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ExtrapolatePrediction(KS.Reactor.ksMultiType,KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ExtrapolatePrediction(`0,`0,System.Single,System.Single,System.Single)">
            <summary>Updates and extrapolates the predicted server value.</summary>
            <param name="startValue">Value before the controller update.</param>
            <param name="controllerValue">Value after the controller update.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Interpolate(KS.Reactor.ksMultiType,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.Interpolate(`0,System.Single,System.Single,System.Single)">
            <summary>Interpolates the client value towards a predicted future server value.</summary>
            <param name="clientValue">Client value to interpolate from.</param>
            <param name="deltaTime">Delta time in seconds.</param>
            <param name="latency">Latency in seconds.</param>
            <param name="convergeMultiplier">Lower values mean we try to converge more aggressively.</param>
            <returns>New client value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksConvergingInputPredictor.Smoother`3.ZeroFillHistory(System.Int32)">
            <summary>Adds zero filled frames of given number to history.</summary>
            <param name="num">Number of zero filled frames that need to be added to history.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates">
            Collection of delegates.
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates.PropertyChangeHandler">
            Property change event handler.
            
            @param   ksMultiType oldValue of property.
            @param   ksMultiType newValue of property.
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates.Factories">
            Factory delegates
        </member>
        <member name="T:KS.Reactor.Client.ksDelegates.Factories.Predictor">
            Predictor factory
            
            @param   ksBaseEntity entity to get predictor for. Null if predicting player/room properties.
            @return  ksIPredictor predictor
        </member>
        <member name="T:KS.Reactor.Client.ksFrameInfo">
            Size and download progress for a frame.
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.Size">
            Frame size in bytes.
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.AmountReceived">
            Number of bytes downloaded for the frame.
        </member>
        <member name="P:KS.Reactor.Client.ksFrameInfo.Progress">
            Amount of frame downloaded from 0 to 1.
        </member>
        <member name="M:KS.Reactor.Client.ksFrameInfo.#ctor(System.Int32,System.Int32)">
            Constructor
            
            @param   int size of frame in bytes.
            @param   int amountReceived in bytes.
        </member>
        <member name="T:KS.Reactor.Client.ksInputMarshaller">
            Sends updates to inputs and notifies registrars when inputs they have registered have changed by setting their
            StateDirty flag. Each room has its own input and registrar that is registered with the marshaller.
        </member>
        <member name="M:KS.Reactor.Client.ksInputMarshaller.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.ksInputMarshaller.AddRegistrar(KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput)">
            Adds a registrar to the list of registrars to notify about input updates.
            
            @param   ksInputRegistrar registrar to add.
            @param   ksInput input to add.
        </member>
        <member name="M:KS.Reactor.Client.ksInputMarshaller.RemoveRegistrar(KS.Reactor.ksInputRegistrar)">
            Removes a registrar from the list of registrars to notify about input updates.
            
            @param   ksInputRegistrar registrar to remove.
        </member>
        <member name="M:KS.Reactor.Client.ksInputMarshaller.SetButton(System.UInt32,System.Boolean)">
            Updates a button's state. If the state changed, sets StateDirty on all registrars with that button registered.
            
            @param   uint button to update.
            @param   bool down - true if the button is down.
        </member>
        <member name="M:KS.Reactor.Client.ksInputMarshaller.SetAxis(System.UInt32,System.Single)">
            Sets the value of an axis. If the value changed, sets StateDirty on all registrars with that axis registered.
            
            @param   uint axis to set value of.
            @param   float value to set.
        </member>
        <member name="T:KS.Reactor.Client.ksIPredictor">
            <summary>Predictor interface for smoothing/predicting entity movement and properties.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksIPredictor.RequiresController">
            <summary>Does the predictor require a player controller?</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.CleanUp">
            <summary>Performs clean up.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.AddProperty(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Initializes smoothing for a property. Called once per property that will be smoothed.</summary>
            <param name="propertyId">Id of property that will be smoothed.</param>
            <param name="value">Property value.</param>
            <param name="smoothingData">Smoothing data for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.ServerUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">
            Server transform and velocity data. Velocity data is currently not synced and is always zero. Null if not
            smoothing a transform.
            </param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.ClientUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">
            Client transform and velocity to update with new values. Null if not smoothing a transform.
            </param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksIPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="T:KS.Reactor.Client.ksIRoom`2">
            Room interface used internally for testing with mock implementations. It is incomplete and only contains
            functions that are needed for testing.
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.IsConnected">
            Are we connected to the server?
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.LocalPlayerId">
            Id of the local player.
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.LocalPlayer">
            The local player.
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.Players">
            List of players connected to the room.
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.Time">
            Time data
        </member>
        <member name="P:KS.Reactor.Client.ksIRoom`2.OnRPC">
            RPC event handler registration.
        </member>
        <member name="E:KS.Reactor.Client.ksIRoom`2.OnPlayerJoin">
            Invoked when a player connects to the room.
        </member>
        <member name="E:KS.Reactor.Client.ksIRoom`2.OnPlayerLeave">
            Invoked when a player disconnects from the room.
        </member>
        <member name="M:KS.Reactor.Client.ksIRoom`2.CallRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Calls an RPC on the server.
        </member>
        <member name="T:KS.Reactor.Client.ksITimeAdjuster">
            Interface for synchronizing time with the server.
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.Initialize">
            Initialization
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.OnServerUpdate(System.Single,System.Single,System.UInt64)">
            Called once per server update.
            
            @param   float deltaTime in seconds of server simulation time (scaled) since the last update.
            @param   float unscaledDeltaTime in seconds of server time since the last update.
            @param   ulong frameNum from the server.
        </member>
        <member name="M:KS.Reactor.Client.ksITimeAdjuster.OnClientUpdate(System.Single,System.Single)">
            Called once per frame to adjust deltaTime to stay in sync with the server.
            
            @param   float deltaTime in seconds of simulation time (scaled and adjusted by previous time adjusters) since
                     last frame.
            @param   float realDeltaTime in seconds of real time (unscaled) since last frame.
            @return  float adjusted delta time in seconds.
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor">
            <summary>Smooths/predicts movement using linear interpolation and extrapolation.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.ConfigData">
            <summary>
            Contains parameters for tuning transform and property smoothing. If a smoothed property does not have a
            correction rate set, <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.PositionCorrectionRate"/> will be used if it is linearly interpolated, and
            <see cref="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.RotationCorrectionRate"/> will be used if it is spherically interpolated. If the property uses
            wrap float interpolation and has no rate set, it will use the difference between the min and the max range
            values.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ConfigData.Default">
            <summary>Default configuration values. Values can be changed to change the defaults.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.PositionCorrectionRate">
            <summary>Position-correction interpolation rate per second.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.RotationCorrectionRate">
            <summary>Rotation-correction interpolation rate in degrees per second.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.ConfigData.ScaleCorrectionRate">
            <summary>Scale-correction interpolation rate per second.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ConfigData.GetPropertyCorrectionRate(System.UInt32,System.Single)">
            <summary>Gets the correction interpolation rate for a property.</summary>
            <param name="propertyId">Id of property to get correction interpolation rate for.</param>
            <param name="defaultRate">Value to return if the property has no rate set.</param>
            <returns>Correction interpolation rate per second for the property.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ConfigData.SetPropertyCorrectionRate(System.UInt32,System.Single)">
            <summary>Sets the correction interpolation rate for a property.</summary>
            <param name="propertyId">Id of property to set correction interpolation rate for.</param>
            <param name="rate">Rate to set.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ConfigData.Clone">
            <summary>Creates a copy of this <see cref="T:KS.Reactor.Client.ksLinearPredictor.ConfigData"/>.</summary>
            <returns>Copy of the config.</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Config">
            <summary>
            Configurable data for customizing the the predictor. Returns null if the predictor is using the
            <see cref="P:KS.Reactor.Client.ksLinearPredictor.ConfigData.Default"/>. Assign this if you want to override the defaults.
            </summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.RequiresController">
            <summary>Always false; the linear predictor does not require a player controller.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Create">
            <summary>Gets a linear predictor instance from the pool, or creates one if the pool is empty.</summary>
            <returns>Predictor instance</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.#ctor">
            <summary>Private constructor. Forces use of object pooling via <see cref="M:KS.Reactor.Client.ksLinearPredictor.Create"/>.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Initialize(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseEntity)">
            <summary>Initializes the predictor.</summary>
            <param name="room">The room object.</param>
            <param name="entity">
            Entity the predictor is smoothing. Null if the predictor is smoothing room or player properties.
            </param>
            <returns>False if the predictor could not be initialized and needs to be removed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.CleanUp">
            <summary>Resets member variables and return the LinearPredictor to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.AddProperty(System.UInt32,KS.Reactor.ksMultiType,KS.Reactor.Client.ksPredictionBehaviour)">
            <summary>Initializes smoothing for a property. Called once per property that will be smoothed.</summary>
            <param name="propertyId">Id of property that will be smoothed.</param>
            <param name="value">Property value.</param>
            <param name="smoothingData">Smoothing data for property prediction.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ServerUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Boolean,System.Boolean)">
            <summary>Called once per server frame.</summary>
            <param name="state">
            Server transform and velocity data. Velocity data is currently not synced and is always zero. Null if not
            smoothing a transform.
            </param>
            <param name="properties">
            Smoothed properties whose values changed since the last frame. Null if no properties have changed.
            </param>
            <param name="teleport">Did the entity teleport?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
            <returns>
            If false and <paramref name="idle"/> is true, this function will not be called again until the server
            transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ClientUpdate(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})">
            <summary>Updates the client transform and properties.</summary>
            <param name="state">
            Client transform and velocity to update with new values. Null if not smoothing a transform.
            </param>
            <param name="properties">
            Smoothed client properties to update with new values. Null if there are no smoothed properties.
            </param>
            <returns>
            If false, this function will not be called again until the server transform or a server property changes.
            </returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.InputUpdate(KS.Reactor.ksInput)">
            <summary>
            Called when a new frame of input is generated. Only called for entities with player controllers.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Advance(System.UInt64,System.Single)">
            <summary>Advances the client simultion.</summary>
            <param name="frameNum">
            Server frame number to advance to. ulong.Max if we are extrapolating passed the last frame.
            </param>
            <param name="time">Time in seconds to advance to in the frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.SetServerValues(KS.Reactor.Client.ksLinearPredictor.Frame)">
            <summary>Initializes the smoothers, checking if correction interpolation is needed.</summary>
            <param name="frame">Initial server frame.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.IterateSmoothers">
            <summary>Iterates the smoothers.</summary>
            <returns>Iterator</returns>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.Frame">
            <summary>Server frame data.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.State">
            <summary>Server transform and velocity state.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Properties">
            <summary>Server properties that changed since the last frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.DeltaTime">
            <summary>Server delta time in seconds since the last frame.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Num">
            <summary>Server frame number.</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Teleport">
            <summary>Did the entity teleport this frame?</summary>
        </member>
        <member name="F:KS.Reactor.Client.ksLinearPredictor.Frame.Idle">
            <summary>True if there were no transform or property changes since the last frame.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Frame.#ctor(KS.Reactor.Client.ksPhysicsState,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Single,System.UInt64,System.Boolean,System.Boolean)">
            <summary>Constructor</summary>
            <param name="state">Server transform and velocity state.</param>
            <param name="properties">Server properties that changed since the last frame.</param>
            <param name="deltaTime">Server delta time in seconds since the last frame.</param>
            <param name="num">Server frame number.</param>
            <param name="teleport">Did the entity teleport this frame?</param>
            <param name="idle">True if there were no transform or property changes since the last frame.</param>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.ISmoother">
            <summary>Interface for smoothing a ksMultiType.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.ISmoother.Correcting">
            <summary>Are we applying correcting interpolation?</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.CleanUp">
            <summary>Resets member variables and return the smoother to an object pool.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.GetValue">
            <returns>Smoothed value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.SetClientValue(KS.Reactor.ksMultiType)">
            <summary>Sets the smoothed value.</summary>
            <param name="value">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.StoreValue">
            <summary>Sets last value to the target.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.Interpolate(System.Single)">
            Interpolates towards the server value.
             <param name="t">Amount to interpolate between 0 and 1.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.FinishInterpolation">
            <summary>Moves to the server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.CheckCorrection">
            <summary>
            Checks if correction interpolation is needed by checking if the target value and the client value are
            different.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.ApplyCorrection(System.Single)">
            <summary>Applies correction interpolation.</summary>
            <param name="deltaTime">Time in seconds since the last update.</param>
            <returns>True if interpolation correction is still needed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.Update(System.Single)">
            <summary>Updates the client value.</summary>
            <param name="deltaTime">Time in seconds since the last update.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the initial server value and checks if correction interpolation is needed.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.SetNextValue(KS.Reactor.ksMultiType,System.Single,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation. Calculates velocity.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="deltaTime">Time in seconds to reach the next value.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.ISmoother.Idle">
            <summary>Stops moving the value.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksLinearPredictor.Smoother`3">
            <summary>Smooths a templated type using a templated <see cref="T:KS.Reactor.Client.ISpace`2"/>.</summary>
            <typeparam name="Vector">The type of value being smoothed.</typeparam>
            <typeparam name="Delta">
            The type returned when subtracting a <see cref="!:Vector"/> from another <see cref="!:Vector"/>.
            </typeparam>
            <typeparam name="Space">The <see cref="T:KS.Reactor.Client.ISpace`2"/> implementation type.</typeparam>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Create(System.Single)">
            <summary>Reuses a smoother from the object pool or creates a new one if the pool is empty.</summary>
            <param name="correctionRate">Rate per second for correction interpolation.</param>
            <returns>Smoother</returns>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Correcting">
            <summary>Are we applying correction interpolation?</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Initialize(System.Single)">
             <summary>Initializes the smoother with a correction rate.</summary>
            <param name="correctionRate">Rate per second for correction interpolation.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.CleanUp">
            <summary>Resets member variables and return the smoother to an object pool.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.ServerValue">
            <summary>Server value.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Value">
            <summary>Smoothed value.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Velocity">
            <summary>Extrapolated rate of change per second.</summary>
        </member>
        <member name="P:KS.Reactor.Client.ksLinearPredictor.Smoother`3.VectorSpace">
            <summary>Vector space instance.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.GetValue">
            <returns>Smoothed value.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetClientValue(KS.Reactor.ksMultiType)">
            <summary>Sets the smoothed value.</summary>
            <param name="value">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.StoreValue">
            <summary>Sets last value to the target.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Interpolate(System.Single)">
            <summary>Interpolates towards the server value.</summary>
            <param name="t">Amount to interpolate between 0 and 1.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.FinishInterpolation">
            <summary>Moves to the server value.</summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.CheckCorrection">
            <summary>
            Checks if correction interpolation is needed by checking if the target value and the client value are
            different.
            </summary>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.ApplyCorrection(System.Single)">
            <summary>Applies correction interpolation.</summary>
            <param name="deltaTime">Time in seconds since last update.</param>
            <returns>True if interpolation correction is still needed.</returns>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Update(System.Single)">
            <summary>Updates the client value.</summary>
            <param name="deltaTime">Time in seconds since last update.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetServerValue(KS.Reactor.ksMultiType)">
            <summary>Sets the initial server value and checks if correction interpolation is needed.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetServerValue(`0)">
            <summary>Sets the initial server value and checks if correction interpolation is needed.</summary>
            <param name="serverValue">Value</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetNextValue(KS.Reactor.ksMultiType,System.Single,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation. Calculates velocity.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="deltaTime">Time in seconds to reach the next value.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.SetNextValue(`0,System.Single,System.Boolean)">
            <summary>
            Sets the next server value to interpolate to and initializes interpolation. Calculates velocity.
            </summary>
            <param name="nextValue">Next value to interpolate to.</param>
            <param name="deltaTime">Time in seconds to reach the next value.</param>
            <param name="teleport">If true, will teleport to the value instead of interpolating.</param>
        </member>
        <member name="M:KS.Reactor.Client.ksLinearPredictor.Smoother`3.Idle">
            <summary>Stops moving the value.</summary>
        </member>
        <member name="T:KS.Reactor.Client.ksNetCounters">
            Network counters
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Add(KS.Reactor.Client.ksNetCounters.CounterType,System.UInt64)">
            Add an amount to a specific counter
            
            @param   CounterType - Counter Type
            @param   ulong - Amount
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Get(KS.Reactor.Client.ksNetCounters.CounterType)">
            Get the amount of a specific counter
            
            @param   CounterType - Counter Type
            @return  ulong - Amount
        </member>
        <member name="M:KS.Reactor.Client.ksNetCounters.Clear">
            Reset all counters
        </member>
        <member name="T:KS.Reactor.Client.ksPhysicsState">
            Physics state
        </member>
        <member name="M:KS.Reactor.Client.ksPhysicsState.Clone">
            @return  PhysicsState a copy of this physics state.
        </member>
        <member name="T:KS.Reactor.Client.ksPlayerControllerFactory">
            Factory for creating player controllers from uint types.
        </member>
        <member name="M:KS.Reactor.Client.ksPlayerControllerFactory.RegisterFromAssembly(System.Reflection.Assembly)">
            Registers all player controllers in an assembly using reflection.
            
            @param   Assembly assembly to load from.
        </member>
        <member name="M:KS.Reactor.Client.ksPlayerControllerFactory.Register(System.Type)">
            Registers a ksPlayerController class so it can be created from it's uint type.
            
            @param   Type type of ksPlayerController to register.
            @return  bool true if the controller was registered successfully.
        </member>
        <member name="M:KS.Reactor.Client.ksPlayerControllerFactory.NextUnusedType">
            Gets the lowest unused type number.
            
            @return  unused type number.
        </member>
        <member name="M:KS.Reactor.Client.ksPlayerControllerFactory.Create(System.UInt32)">
            Creates a player controller.
            
            @param   uint type of controller to create.
            @return  ksPlayerController created, or null if unsuccessful.
        </member>
        <member name="T:KS.Reactor.Client.ksPredictionBehaviour">
            Contains rules for how a property behaves during prediction
        </member>
        <member name="T:KS.Reactor.Client.ksPredictionBehaviour.Types">
            Prediction rules to use on the client.
            
            NONE                 Do not interpolate.
            LINEAR_FLOAT         Use linear interpolation on float.
            LINEAR_VECTOR2       Use linear interpolation on ksVector2.
            LINEAR_VECTOR3       Use linear interpolation on ksVector3.
            LINEAR_COLOR         Use linear interpolation on ksColor.
            WRAP_FLOAT           Use linear interpolation on float and wrap onto [min, max].
            SPHERICAL_VECTOR2    Use spherical interpolation on ksVector2.
            SPHERICAL_VECTOR3    Use spherical interpolation on ksVector3.
            QUATERNION           Use spherical interpolation on ksQuaternion.
            CLIENT               The client player controller has full control over the local property value. If the
                                 controller does not set the property value, the server value is used. The server is
                                 still authoritative; the client does not decide what other clients see.
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Min">
            Minimum property value.
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Max">
            Maximum property value.
        </member>
        <member name="F:KS.Reactor.Client.ksPredictionBehaviour.Type">
            Type of smoothing to use.
        </member>
        <member name="M:KS.Reactor.Client.ksPredictionBehaviour.#ctor(KS.Reactor.Client.ksPredictionBehaviour.Types,System.Single,System.Single)">
            Constructor
            
            @param   Types - Type of smoothing to use during prediction
            @param   float - Min value use for Types.WRAP_FLOAT
            @param   float - Max value use for Types.WRAP_FLOAT
        </member>
        <member name="T:KS.Reactor.Client.ksPredictorUtils">
            Client-side prediction utils.
        </member>
        <member name="T:KS.Reactor.Client.ksPredictorUtils.PhysicsFlags">
            Flags for controlling what physics to simulate.
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.UpdateController(KS.Reactor.Client.ksBaseEntity,System.Single,KS.Reactor.ksInput,KS.Reactor.Client.ksPredictorUtils.PhysicsFlags)">
            Updates a transform based on a player controller update.
            
            @param   ksBaseEntity entity with player controller to update.
            @param   float deltaTime in seconds.
            @param   ksInput input for the controller. If null, the current input will be used.
            @param   PhysicsFlags flags to determine what physics to simulate.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksPredictorUtils.ApplyClientProperties(KS.Reactor.Client.ksBaseEntity,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType})" -->
        <member name="M:KS.Reactor.Client.ksPredictorUtils.SweepAndSlide(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion)">
            Attempts to move an entity from one position to another by performing a sweep. If it collides
            with something, it will slide perpendicular to the surface normal of the collision by calling
            this function recursively.
            
            @param   ksBaseEntity entity to sweep.
            @param   ksVector3 from - start position.
            @param   ksVector3 to - target position.
            @param   ksQuaternion rotation.
            @return  ksVector3 end position.
        </member>
        <member name="M:KS.Reactor.Client.ksPredictorUtils.SweepAndSlide(KS.Reactor.Client.ksBaseEntity,KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Int32)">
            Attempts to move the entity from one position to another by performing a sweep. If it collides
            with something, it will slide perpendicular to the surface normal of the collision by calling
            this function recursively.
            
            @param   ksBaseEntity entity to sweep.
            @param   ksVector3 from - start position.
            @param   ksVector3 to - target position.
            @param   ksQuaternion rotation.
            @param   ksVector3 originalDirection of movement before and sliding.
            @param   int maxIterations - number of times this can be called recursively.
            @return  ksVector3 end position.
        </member>
        <member name="T:KS.Reactor.Client.ksService">
            Main entry point to connect to the service.
        </member>
        <member name="P:KS.Reactor.Client.ksService.AppDataPath">
            Path to write app data to.
        </member>
        <member name="P:KS.Reactor.Client.ksService.KinematicSoupPath">
            Path to KinematicSoup folder.
        </member>
        <member name="P:KS.Reactor.Client.ksService.StaticModelPath">
            Path to static model.
        </member>
        <member name="P:KS.Reactor.Client.ksService.ModelChecksum">
            Model checksum
        </member>
        <member name="P:KS.Reactor.Client.ksService.ModelData">
            Model data
        </member>
        <member name="P:KS.Reactor.Client.ksService.Coroutines">
            Coroutine manager
        </member>
        <member name="P:KS.Reactor.Client.ksService.InputMarshaller">
            Input Marshaller
        </member>
        <member name="P:KS.Reactor.Client.ksService.PlayerControllerFactory">
            Player Controller Factory
        </member>
        <member name="P:KS.Reactor.Client.ksService.WebRequestFactory">
            Factory for providing custom ksIWebRequest implementations.
        </member>
        <member name="P:KS.Reactor.Client.ksService.PlayerAPI">
            Player account API
        </member>
        <member name="P:KS.Reactor.Client.ksService.Rooms">
            List of rooms we are connected or connecting to.
        </member>
        <member name="M:KS.Reactor.Client.ksService.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.ksService.CoroutineWebRequestHandler(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            This alternative web request handler manages the request with the coroutine manager therefore ensuring the
            completion handler is called on the main update thread.
            
            @param   string - URL
            @param   WebHeaderCollection - additional request headers
            @param   string - request method
            @param   ksJSON - post request data
            @param   ksWebResponse.Handler - request callback
            @param   object - state object returned in the callback
            @return  null
        </member>
        <member name="M:KS.Reactor.Client.ksService.Disconnect(System.Boolean)">
            Disconnects from all rooms.
            
            @param   bool immediate - if false, waits for pending writes before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksService.JoinRoom(KS.Reactor.Client.ksBaseRoom,KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[])">
            Connects to a room.
            
            @param   ksBaseRoom room to join.
            @param   ksPlayerAPI.Session player session credentials.
            @param   params ksMultiType[] authentication arguments
            @return  bool false if a connection attempt was not made because of invalid parameters or because we're
                     already connected or connecting to the room.
        </member>
        <member name="M:KS.Reactor.Client.ksService.HasConnection(KS.Reactor.Client.ksBaseRoom)">
            Test if the service already has a connection to a room
            
            @param   ksBaseRoom room
            @return  bool
        </member>
        <member name="M:KS.Reactor.Client.ksService.LeaveRoom(KS.Reactor.Client.ksBaseRoom,System.Boolean)">
            Disconnects from a room.
            
            @param   ksBaseRoom room to leave.
            @param   bool immediate - if false, waits for pending writes before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksService.GetServers(System.String,System.String,KS.Reactor.Client.ksService.RoomListCallback)">
            Request a list of running server instances
            
            @param   string - url
            @param   string - image binding
            @param   RoomListCallback - callback
        </member>
        <member name="M:KS.Reactor.Client.ksService.Update(System.Single,System.Single)">
            Called each frame.
            
            @param   float deltaTime - game time in seconds since the last update.
            @param   float realDeltaTime - real time in seconds since the last update. If less than zero, will be
                     calculated.
        </member>
        <member name="M:KS.Reactor.Client.ksService.OnRoomStateChange(KS.Reactor.Client.ksBaseRoom,KS.Reactor.Client.ksBaseRoom.ConnectionStates)">
            Called when a room connection state changes
            
            @param   ksBaseRoom - room the connection attempt was for.
            @param   ksBaseRoom.ConnectionStates -  status of the connection.
        </member>
        <member name="M:KS.Reactor.Client.ksService.SetStaticModel(System.IO.Stream,System.Boolean)">
            Set static model.
            
            @param   Stream modelStream to read model from
            @param   bool saveToFile
        </member>
        <member name="T:KS.Reactor.Client.ksTCPConnection">
            Network stream connection using sockets and the TCP protocol.
        </member>
        <member name="T:KS.Reactor.Client.ksTCPConnection.ConfigSettings">
            Configuration options for TCP connections
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.Config">
            Configuration settings used for new TCP connections.
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.IsConnected">
            Check if a connection to the server is open.
            
            @return  bool
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.ReadProgress">
            Get the progress of the current read operation.
            
            @return  ksFrameInfo
        </member>
        <member name="P:KS.Reactor.Client.ksTCPConnection.WriteProgress">
            Get the progress of the current write operation.
            
            @return  ksFrameInfo
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Connect(System.String,System.UInt16,KS.Reactor.Client.ksConnection.ConnectHandler,System.Object)">
            Establish a connection to a server.
            
            @param   string - server host name
            @param   ushort - server port
            @param   ConnectHandler - callback to invoke when the connection attempt completes
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Disconnect(System.Boolean)">
            Disconnect from the server.
            
            @param   bool - immediate. If this is false, then queued write operations will complete before disconnecting.
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Read(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            Read data from the connection into a stream buffer segment.
            
            @param   ksStreamBuffer.Segment - segment of a larger stream buffer
            @param   IOHandler - callback to invoke when the read operation completes
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Write(KS.Reactor.ksStreamBuffer.Segment,KS.Reactor.Client.ksConnection.IOHandler,System.Object)">
            Write data to the socket.
            
            @param   ksStreamBuffer.Segment - segment of a larger stream buffer
            @param   IOHandler - callback to invoke when the write operation completes
            @param   object - asynchronous state
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.HandleAsyncConnect(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            Handle a connect event from the TCP socket by calling the connect handler.
            
            @param   object - socket that attempted the connection
            @param   SocketAsyncEventArgs - async event argurments
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOExecute(KS.Reactor.Client.ksConnection.IOOperation)">
            Execute an asynchronous IO operation.
            
            @param   IOOperation - IO operation
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOContinue(System.Net.Sockets.SocketAsyncEventArgs)">
            Check the async event arguments and call the appropriate async action on the socket.
            
            @param   SocketAsyncEventArgs - async event argurments
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.IOComplete(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            Handle the completion of a socket action.
            
            @param   object - socket attempted the IO action
            @param   SocketAsyncEventArgs - async event argurments
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.Disconnect(System.Net.Sockets.SocketError)">
            Handle a disconnection error/completion event.
            
            @param   SocketError - Reason for disconnect
        </member>
        <member name="M:KS.Reactor.Client.ksTCPConnection.DiagnoseConnectionFailure(System.String,System.UInt16)">
            Diagnose Connection Failure to the server.
            
            @param   string - host
            @param   ushort - port
            @return  string - error (null if no connection errors could be determined)
        </member>
        <member name="T:KS.Reactor.Client.ksTimeKeeper">
            Smoothly adjusts client time deltas to keep in sync with the server. Controls time values that determine how far
            predictors should interpolate/extrapolate the server frame data. 
        </member>
        <member name="T:KS.Reactor.Client.ksTimeKeeper.Frame">
            Server frame timing data.
        </member>
        <member name="F:KS.Reactor.Client.ksTimeKeeper.Frame.DeltaTime">
            Delta time of frame in seconds.
        </member>
        <member name="F:KS.Reactor.Client.ksTimeKeeper.Frame.Num">
            Frame number
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Frame.#ctor(System.Single,System.UInt64)">
            Constructor
            
            @param   float deltaTime in seconds.
            @param   ulong num - frame number.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.Drift">
            How far ahead or behind in seconds we've drifted from the target latency. Each server frame received
            decreases this number.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TargetLatency">
            How far behind each server frame we try to be when that server frame arrives. Increasing reduces the
            likelyhood of getting ahead of the latest server frame, which increases client simulation accuracy as we
            won't have to extrapolate object transforms as often, but it also increases latency. By default this is set
            to zero to favour the lowest latency possible.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.MinAdjustmentDuration">
            Minimum duration of time adjustment in seconds. Time adjustments are applied over multiple frames to make
            the adjustment smooth. The adjustment duration is the larger of this amount or twice the time being
            corrected, unless the time correction exceeds max drift, in which case we do a near-instant time adjustment.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.DriftThreshold">
            Drift theshold in seconds to try keep the drift within. Smaller values will trigger time adjustments more
            frequently.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.NumDriftExceeds">
            Number of consecuitive drift samples exceeding the threshold needed to trigger time correction.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.MaxDrift">
            Max drift behind the server in seconds before applying a near-instant time correction. The adjustment still
            takes multiple frames so if more server frames arrive before we finish the adjustment, we increase the time
            correction and time adjustment duration to include them rather than doing multiple instant adjustments.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.Extrapolating">
            Are we extrapolating passed the last frame?
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.FrameNum">
            Frame number for the server frame we are currently interpolating. ulong.MaxValue if we are extrapolating.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TimeOffset">
            How long in seconds we are extrapolating or interpolating in the current frame.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.LastFrameNum">
            Frame number for the server frame we were interpolating last update.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.LastTimeOffset">
            How long in seconds we were extrapolating or interpolating last update.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeKeeper.TimeCorrection">
            Amount in seconds time is being corrected by.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Initialize">
            Initialization
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.OnServerUpdate(System.Single,System.Single,System.UInt64)">
            Called once per server update. Updates drift and checks if we need to initiate a time correction.
            
            @param   float deltaTime in seconds of server simulation time (scaled) since the last update.
            @param   float unscaledDeltaTime in seconds of server time since the last update.
            @param   ulong frameNum from the server.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.OnClientUpdate(System.Single,System.Single)">
            Called once per frame to adjust deltaTime to stay in sync with the server. Advances time offset and frame
            num for predictor interpolation/extrapolation.
            
            @param   float deltaTime in seconds of simulation time (scaled and adjusted by previous time adjusters) since
                     last frame.
            @param   float realDeltaTime in seconds of real time (unscaled) since last frame.
            @return  float adjusted delta time in seconds.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.UpdateExceedCount">
            Updates exceed count (number of consecuitive drifts exceeded the threshold).
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.Advance(System.Single)">
            Advances the current frame and interpolation/extrapolation time.
            
            @param   float deltaTime in seconds to advance by.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.GetAdjustment(System.Single)">
            Calculates time adjusted for time correction.
            
            @param   float time - how long we have been adjusting time.
            @return  float amount to adjust time by.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.AdjustDeltaTime(System.Single)">
            Adjusts deltaTime for time correction. Time is adjusted using a sine wave so the adjustment smoothly starts
            and stops.
            
            @param   float deltaTime to adjust.
            @return  float adjusted delta time.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeKeeper.InitTimeCorrection(System.Single)">
            Initializes time correction.
            
            @param   float timeCorrection in seconds.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ksTimeKeeper.CheckTimeCorrection(System.Int32)" -->
        <member name="T:KS.Reactor.Client.ksTimeRestrainer">
            Simple time synchronizer that slows down and eventually stops incrementing time after long periods with no
            updates from the server.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.SlowTime">
            Real time in seconds after which extrapolation rate slows down if no server updates are received.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.MaxTime">
            Real time in seconds after which extrapolation stops if no server updates are received.
        </member>
        <member name="P:KS.Reactor.Client.ksTimeRestrainer.ExtrapolationTime">
            How long we've been extrapolating without a server update in seconds.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.#ctor(System.Single,System.Single)">
            Constructor
            
            @param   slowTime - time in seconds after which extrapolation rate slows down if no server updates are received.
            @param   maxTime - time in seconds after which extrapolation stops if no server updates are received.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.Initialize">
            Initialization
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.OnServerUpdate(System.Single,System.Single,System.UInt64)">
            Called once per server update.
            
            @param   @param   float deltaTime in seconds of server simulation time (scaled) since the last update.
            @param   float unscaledDeltaTime in seconds of server time since the last update.
            @param   ulong frameNum from the server.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.OnClientUpdate(System.Single,System.Single)">
            Called once per frame to adjust deltaTime to stay in sync with the server.
            
            @param   float deltaTime in seconds of simulation time (scaled and adjusted by previous time adjusters) since
                     last frame.
            @param   float realDeltaTime in seconds of real time (unscaled) since last frame.
            @return  float adjusted delta time in seconds.
        </member>
        <member name="M:KS.Reactor.Client.ksTimeRestrainer.AdjustTime(System.Single)">
            Adjusts extrapolation time to slow down extrapolation rate when extrapolation runs longer than m_slowTime.
            
            @param   float time - duration of extrapolation.
            @return  float adjusted extrapolation time.
        </member>
        <member name="T:KS.Reactor.Client.ksVersion">
            Version number consistig of major, minor, revision, and build.
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Current">
            Current API version.
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Major">
            Major number
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Minor">
            Minor number
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Revision">
            Revision number
        </member>
        <member name="P:KS.Reactor.Client.ksVersion.Build">
            Build number
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            Constructor
            
            @param   uint major number
            @param   uint minor number
            @param   uint revision number
            @param   uint build number
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.FromString(System.String)">
            Constructs a ksVersion from a version string.
            
            @param   string versionString consisting of major, minor, revision, and build seperated by '.' or '-'.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Parse(System.String)">
            Sets version numbers by parsing a version string.
            
            @param   string versionString to parse.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.CreateException(System.String)">
            Creates an ArgumentException.
            
            @param   string version string that triggered the exception.
            @return  ArgumentException
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.ToString">
            @return  string version string.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_Equality(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if two versions are the same.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if the versions are the same.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_Inequality(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if two versions are different.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if the versions are different.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_LessThan(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if a version is older than another.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if lhs is older than rhs.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_LessThanOrEqual(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if a version is older or equal to another.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if lhs is older or equal to rhs.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_GreaterThan(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if a version is newer than another.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if lhs is newer than rhs.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.op_GreaterThanOrEqual(KS.Reactor.Client.ksVersion,KS.Reactor.Client.ksVersion)">
            Checks if a version is newer or equal to another.
            
            @param   ksVersion lhs
            @param   ksVersion rhs
            @return  bool true if lhs is newer or equal to rhs.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Equals(System.Object)">
            Checks if this version is equal to an object.
            
            @param   object obj to compare with.
            @return  bool true if this version is equal to the object.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.Equals(KS.Reactor.Client.ksVersion)">
            Checks if the version is the same as another.
            
            @param   ksVersion other to compare with.
            @return  bool true if the versions are the same.
        </member>
        <member name="M:KS.Reactor.Client.ksVersion.GetHashCode">
            @return  int hash code.
        </member>
        <member name="T:KS.Reactor.Client.PropertySync">
            Holds properties and provides methods for updating properties.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ChangedValues">
            Smoothed property values from the server that have changed since the last server frame, indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ClientValues">
            Smoothed property values, indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.ServerValues">
            Server property values for smoothed properties, indexed by property id.
        </member>
        <member name="P:KS.Reactor.Client.PropertySync.Predictor">
            Predictor for smoothing property values.
        </member>
        <member name="F:KS.Reactor.Client.PropertySync.m_propertyChangeEventMap">
            Invoked when a room property changes. Indexed by property id.
        </member>
        <member name="F:KS.Reactor.Client.PropertySync.m_propertyMap">
            Properties
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.GetPropertyServerValue(System.UInt32)">
            Gets property server value.
            
            @param   uint propertyId
            @return  ksMultiType
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.CloneWithServerValues">
            Creates a copy of this property sync that uses server values instead of smoothed values.
            
            @return  PropertySync copy of this property sync with server values.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.MergeWith(KS.Reactor.Client.PropertySync)">
            Copies the property change event handlers and prediction behaviours from another property sync into this one.
            
            @param   PropertySync other to copy handlers and prediction behaviours from.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.PropertySync.CopyServerValues" -->
        <member name="M:KS.Reactor.Client.PropertySync.Push(System.UInt32,KS.Reactor.ksMultiType)">
            Queues a property update.
            
            @param   uint propertyId of property to update.
            @param   ksMultiType property value.
            @return  bool true if the property has smoothing enabled.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.FinishFrame">
            Calls ServerUpdate on the predictor with properties whose values have changed since the last server frame.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.SmoothUpdate">
            Updates smoothed properties using the predictor.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.Update">
            Processes queued property updates.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.Clear">
            Clears all properties
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.SetPredictionBehaviour(System.UInt32,KS.Reactor.Client.ksPredictionBehaviour)">
            Sets smoothing data for a property.
            
            @param   uint property Id
            @param   ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.GetPredictionBehaviour(System.UInt32)">
            Gets smoothing data for a property.
            
            @param   uint property Id
            @return  ksPredictionBehaviour - Behaviour of the property when predicting and smoothing values.
        </member>
        <member name="M:KS.Reactor.Client.PropertySync.Set(System.UInt32,KS.Reactor.ksMultiType)">
            Sets a property value.
            
            @param   uint propertyId of property to set.
            @param   ksMultiType value to set property to.
        </member>
        <member name="T:KS.Reactor.Client.ServerFrame">
            Server frame.
        </member>
        <member name="M:KS.Reactor.Client.ServerFrame.#ctor">
            Default Constructor
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ServerFrame.Initialize(KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3,System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Single,System.Boolean,System.UInt64)" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Client.ServerFrame.Initialize(System.Collections.Generic.Dictionary{System.UInt32,KS.Reactor.ksMultiType},System.Single,System.UInt64)" -->
        <member name="M:KS.Reactor.Client.ServerFrame.Cleanup">
            Reset member variables and return the ServerFrame to an object pool.
        </member>
        <!-- Badly formed XML comment ignored for member "T:KS.Reactor.Client.SyncObject" -->
        <member name="P:KS.Reactor.Client.SyncObject.IsDestroyed">
            Have we recieved a destroy event for this sync object
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.LastUpdateFrame">
            Last frame we received a transform or smoothed property update from the server.
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.Id">
            Entity id
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.Type">
            Entity type
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.SyncGroup">
            Sync Group
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.ControllerType">
            Player controller type
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.ControllerAssetId">
            Player controller asset id.
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.ServerState">
            State from the server.
        </member>
        <!-- Badly formed XML comment ignored for member "P:KS.Reactor.Client.SyncObject.ClientState" -->
        <member name="P:KS.Reactor.Client.SyncObject.Entity">
            Entity
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.Teleported">
            Teleported
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.PropertySync">
            Property sync
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.CompressorUtility">
            CompressorUtility
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.IsIdle">
            Is this object idle? Idle objects aren't moving and aren't changing properties.
        </member>
        <member name="P:KS.Reactor.Client.SyncObject.ServerGhostEntity">
            Server ghost entity
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.Initialize(KS.Reactor.Client.ksPlayerControllerFactory,KS.Reactor.Client.ksDelegates.Factories.Predictor)">
            Initialization
            
            @param   ksPlayerControllerFactory playerControllerFactory for creating player controllers.
            @param   ksDelegates.Factories.Predictor predictorFactory for creating non-input predictor.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.ZeroVelocities">
            Zeros the client state velocities.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.SetServerPosition(System.Int32,System.Single)">
            Sets a server position value.
            
            @param   int index of value to set (0: X, 1: Y, 2: Z).
            @param   float value to set.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.SetServerScale(KS.Reactor.ksVector3)">
            Sets server scale.
            
            @param   ksQuaternion scale to set.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.SetServerRotation(KS.Reactor.ksQuaternion)">
            Sets server rotation.
            
            @param   ksQuaternion rotation to set.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.UpdateServerState(System.Single,System.UInt64)">
            Advances the server state values one frame.
            
            @param   float serverDeltaTime in seconds since last update.
            @param   ulong frameNum - server frame number.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.UpdateClientState(System.Single)">
            Updates client state.
            
            @param   deltaTime in seconds since last frame.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.UpdateClientTransform">
            Updates the client entity transform.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.PushProperty(System.UInt32,KS.Reactor.ksMultiType)">
            Queues a property update.
            
            @param   uint propertyId of property to update.
            @param   ksMultiType property value.
            @return  bool true if the property has smoothing enabled.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.PredictProperties">
            Predicts property values that use property smoothing.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.InitializeScripts">
            Initializes entity scripts.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.Destroy(System.Boolean)">
            Destroys the tracked entity then reset member variables before returning the SyncObject to an object pool.
            
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.SyncController">
            Creates and sets a new player controller if the controller type changed.
        </member>
        <member name="M:KS.Reactor.Client.SyncObject.InitializePredictor">
            Initializes a predictor for smoothing motion and properties of this sync object.
        </member>
        <member name="T:KS.Reactor.Client.WebServerAPI">
            A static class for communicating with Reactor server managers
        </member>
        <member name="P:KS.Reactor.Client.WebServerAPI.WebRequestFactory">
            Factory for creating ksIWebRequests.
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.GetServers(System.String,System.String,KS.Reactor.Client.ksService.RoomListCallback)">
            Coroutine for requesting a list of public instances
            
            @param   string - url of the publish service
            @param   string - image binding string [company id].[project id].[image id]
            @param   RoomListCallback callback
            @return  IEnumerator
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.AsyncRequest(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            Async request
            
            @param   string - URL
            @param   WebHeaderCollection - additional request headers
            @param   string - request method
            @param   ksJSON - post request data
            @param   ksWebResponse.Handler - request callback
            @param   object - state object returned in the callback
            @return  IEnumerator
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.SyncRequest(System.String,System.Net.WebHeaderCollection,System.String,KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler,System.Object)">
            Synchronous request
            
            @param   string - URL
            @param   WebHeaderCollection - additional request headers
            @param   string - request method
            @param   ksJSON - post request data
            @param   ksWebResponse.Handler - request callback
            @param   object - state object returned in the callback
        </member>
        <member name="M:KS.Reactor.Client.WebServerAPI.AsyncUploadRequest(System.String,System.IO.FileInfo[],KS.Reactor.ksJSON,KS.Reactor.ksWebResponse.Handler)">
            Async file upload request
            
            @param   string - url
            @param   FileInfo[] - list of files to upload
            @param   ksJSON - request data
            @param   RequestCallback - response callback
            @return  IEnumerator
        </member>
        <!-- Badly formed XML comment ignored for member "T:KS.Reactor.Client.Adaptors.ksEntity" -->
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.Room">
            Room the entity is in.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.Scripts">
            List of scripts attached to the entity.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntity.AssetId">
            Asset Id for prefab
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.#ctor">
            Default constructor
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.Initialize(System.UInt32,System.UInt32)">
            Initialize an entity
            
            @param   uint - Entity ID
            @param   uint - Asset ID
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.InitializeScripts">
            Initializes entity scripts.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.Destroy(System.Boolean)">
            Detaches all scripts and cleans up the entity for reuse.
            
            @param   bool - True when the entity is destroyed because it is in a different sync group than the local player.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.ResolvePenetration(KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion)">
            Resolves penetrations resulting from moving between two points. This is not implemented.
            
            @param   ksVector3 from - start position.
            @param   ksVector3 to - end position.
            @param   ksQuaternion rotation.
            @return  ksVector3 position between start and end points before penetration occurred, 
                     or end position if no penetration occurred.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.Sweep(KS.Reactor.ksVector3,KS.Reactor.ksVector3,KS.Reactor.ksQuaternion,KS.Reactor.ksVector3@,KS.Reactor.ksVector3@)">
            Checks if the entity will collide with anything when moving between two points. This is not implemented.
            
            @param   ksVector3 from - position to sweep from.
            @oaram   ksVector3 to - position to sweep to.
            @param   ksQuaternion rotation
            @param   out ksVector3 position of the entity at the end of the sweep. If a collision occurred, this is
                     the entity's position when it happened.
            @param   out ksVector3 normal of collision surface.
            @return  bool true if a collision occured.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.BecomeServerGhost">
            Indicate this is a server ghost. Server ghosts are duplicate entities used for debugging
            with no movement smoothing so they are always rendered at the last server position.
            This is not implemented.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.SetVisible(System.Boolean)">
            Hides or shows the entity.
            This is not implemented.
            
            @param   bool visible - true if the entity should be visible.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksEntity.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Invoke managed RPCs on all entity scripts.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksEntityScript">
            Base class for scripts that can be attached to entities.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Entity">
            Entity this script is attached to.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Room">
            Room the entity is in.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Time">
            Server time and local frame delta.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksEntityScript.Properties">
            Entity properties
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksPlayer">
            Engine agnostic implementation of ksBasePlayer.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayer.Room">
            Room the player is in.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayer.Scripts">
            List of scripts attached to the player.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.#ctor(System.UInt32)">
            Constructor
            
            @param   uint id of the player.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.InitializeScripts">
            Initializes player scripts.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksPlayer.Destroy">
            Detaches all scripts.
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksPlayerScript">
            Base class for scripts that can be attached to players.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Player">
            Player this script is attached to.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Room">
            Room the player is in.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Time">
            Server time and local frame delta.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksPlayerScript.Properties">
            Player properties
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoom">
            Engine agnostic stub implementation of ksBaseRoom. Prefabs/types and physics are not implemented.
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoom.UpdateHandler">
            Update event handler.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Scripts">
            List of scripts attached to the room.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Physics">
            This is not implemented and will be null.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.Gravity">
            Gravity
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoom.OnUpdate">
            Delegates are invoked every update in sorted order of indices.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.#ctor(KS.Reactor.ksRoomInfo)">
            Constructor
            
            @param   ksRoomInfo roomInfo determines where we connect.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.#ctor">
            Constructor
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.CreatePlayer(System.UInt32)">
            Creates a player.
            
            @param   uint id of player.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.CreateEntity(System.UInt32,System.UInt32,System.Boolean)">
            Creates an entity.
            
            @param   uint id of entity.
            @param   uint type of entity.
            @param   bool isGhost - if true, we are creating an entity for a server ghost
            @return  ksEntity
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.LoadPlayerScripts(KS.Reactor.Client.Adaptors.ksPlayer)">
            Loads and attaches player scripts to a player. This is not implemented.
            
            @param   ksPlayer player to attach scripts to.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.InitializeScripts">
            Initializes room scripts.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.UpdateScripts">
            Calls registered update handlers.
        </member>
        <member name="M:KS.Reactor.Client.Adaptors.ksRoom.InvokeRPC(System.UInt32,KS.Reactor.ksMultiType[])">
            Invoke managed RPCs on all room scripts.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
        </member>
        <member name="T:KS.Reactor.Client.Adaptors.ksRoomScript">
            Base class for scripts that can be attached to rooms.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Room">
            Room the script is attached to.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Time">
            Server time and local frame delta.
        </member>
        <member name="P:KS.Reactor.Client.Adaptors.ksRoomScript.Properties">
            Room properties
        </member>
        <member name="T:KS.Reactor.Secret.BaseDecompressor">
            Base class for all decompressors
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress data compressed by a compressor into a new byte array.
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Deserialize the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.BaseDecompressor.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Deserialize the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Reactor.Secret.BaseFrameSectionDecoder">
            This class defines common constants and interface function required for all frame section decoders.
            Derived classes are responsible for parsing client, entity, controller information for a single
            frame of server data.
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool is this a full client frame
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BaseFrameSectionDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingleDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="T:KS.Reactor.Secret.BFDecompressor">
            This class decodes data compressed by BinaryFlagCompressor.
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.SetStaticModelData(System.Byte[])">
            Parse and update the static model data.
            
            @param   byte[] - model data
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress data compressed by BinaryFlagCompressor into a new byte array.
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Deserialize the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.BFDecompressor.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Deserialize the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder">
            Decodes frame data that was encoded using a binary flag compressor.
        </member>
        <member name="M:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BinaryFlagFrameSectionDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingle - if true, decode this update to single delta.
            @param   bool applyDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="T:KS.Reactor.Secret.BitStreamDecoder">
            Decodes frame data that was encoded using a bit stream encoder.
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number controllers to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number events to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool is this a full client frame
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingleDelta
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.BitStreamDecoder.DecodeRPC(KS.Reactor.ksBitIStream,System.UInt32@,KS.Reactor.ksMultiType[]@)">
            Decodes an RPC.
            
            @param   ksBitIStream srcData to process.
            @param   out uint rpcId.
            @param   out KSMultiType[] arguments.
        </member>
        <member name="T:KS.Reactor.Secret.EntityArrayManager">
            This class manages the entity indices. We send entity data in order to avoid sending entity ids.
            The EntityArrayManager will generate an index for a new entity and record it so we can get the entity id
            for an entity when its udpate data is decoded.
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.GetNextIndex">
            Gets the next available index.
            
            @return  int
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.ReserveIndex">
            Reserve the next highest encoding index for reuse in a later frame.
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.AddEntityId(System.UInt32)">
            Puts the given entity id at the next available index.
            
            @param   uint entity id
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.GetEntityId(System.Int32)">
            Gets the entity id at the given index.
            
            @param   int index
            @return  uint entity id - 0 means there is no entity at the given index
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecoverIndexForEntity(System.UInt32)">
            Recovers the index of the given entity. Removes this entity id from the entity array.
            Adds this entity's index to the list of indices that we can assign to a new entity.
            
            @param   uint entityId
            @return  bool return true if the entity was found and the index was recovered
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecoverIndex(System.Int32)">
            Recovers the given index. Adds this index to the list of indices that we can assign to a new entity.
            
            @param   int index
        </member>
        <member name="M:KS.Reactor.Secret.EntityArrayManager.RecycleIndices">
            Move recovered indices into the available indices list and sort it.
        </member>
        <member name="T:KS.Reactor.Secret.FixedLengthDecoder">
            Decodes frame data that was encoded using a fixed length compressor.
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodePlayerController(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and attach player controllers to entities and process input acknowledgements
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeServerEvents(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode and apply server events such as RPCs and connect/disconnects
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeClientProperties(System.Byte[],System.Int32,System.UInt32,System.Boolean,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply client property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   bool activate existing clients
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeEntityProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply entity property updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeRoomProperties(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate)">
            Decode and apply room property updates and gravity changes
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number properties to decode
            @param   RoomUpdate frame Data
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeNewEntities(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode new entities
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.ApplyFixedPointObject(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.FixedPointObject@,System.UInt32)">
            Apply the given fixed point object to its sync object. Create a new sync object if none was found.
            
            @param   RoomUpdate frame Data
            @param   FixedPointObject fpEntity
            @param   uint Sync group
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.DecodeEntityUpdates(System.Byte[],System.Int32,System.UInt32,KS.Reactor.Secret.RoomUpdate,System.Boolean,System.UInt32,KS.Reactor.Secret.EntityArrayManager)">
            Decode entity transform updates
            
            @param   byte[] source data
            @param   int data offset
            @param   uint number entities to decode
            @param   RoomUpdate frame Data
            @param   bool isSingle - if true, decode this update to single delta.
            @param   uint Sync group
            @param   EntityArrayManager Entity array manager
        </member>
        <member name="M:KS.Reactor.Secret.FixedLengthDecoder.ApplyFixedPointTransform(KS.Reactor.Secret.RoomUpdate,KS.Reactor.Secret.FixedPointTransform,System.Boolean,System.UInt32)">
            Apply the given fixed point transform to its sync object.
            
            @param   RoomUpdate frame Data
            @param   FixedPointTransform fpTransform
            @param   bool isSingle - if true, assign single delta. Otherwise, apply double delta onto the single delta.
            @param   bool applyDelta
            @param   uint Sync group
        </member>
        <member name="T:KS.Reactor.Secret.FLCompressor">
            Compresses unordered arrays of fixed-length data.
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressor.Compress``1(``0[])">
            Compresses an ordered array of structs.
            
            @param   T[] values to compress.
            @return  byte[] compressed data.
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressor.CompressData(System.Byte[],System.Int32,System.Int32)">
            Compresses a byte array of unordered fixed-length objects.
            
            @param   byte[] data to compress.
            @param   int objectSize
            @param   int objectCount
            @return  byte[] compressed data.
        </member>
        <member name="T:KS.Reactor.Secret.FLCompressorUtility">
            Utility class for FLCompressor. It is used last transform data and deltas in int arrays and the precisions.
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.Position">
            Position
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.Rotation">
            Rotation
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.Scale">
            Scale
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.DeltaPosition">
            DeltaPosition
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.DeltaRotation">
            DeltaRotation
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.DeltaScale">
            DeltaScale
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.HasReceivedUpdates">
            The compressor will have non-null delta positions, rotations, or scales if we have received an update.
            
            @return bool
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.PositionPrecision">
            Position Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.RotationPrecision">
            Rotation Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.ScalePrecision">
            Scale Precision
        </member>
        <member name="P:KS.Reactor.Secret.FLCompressorUtility.UseUpdateServerTransform">
            We don't need to call UpdateServerTransform.
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressorUtility.UpdateServerTransform(KS.Reactor.Client.ksPhysicsState@,System.Single)">
            Called to advance the server transform one frame. Does nothing.
            
            @param   ref ksPhysicsState serverState
            @param   float serverDeltaTime
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressorUtility.OnNewServerPositionUpdate(System.Int32)">
            Called when a new server position is received. Does nothing.
            
            @param   int index of position that changed (1, 2, or 3 for x, y, or z).
        </member>
        <member name="M:KS.Reactor.Secret.FLCompressorUtility.OnNewServerRotationUpdate">
            Called when a new server rotation is received. Does nothing.
        </member>
        <member name="T:KS.Reactor.Secret.FLDecompressor`1">
            This class decodes data compressed by FLCompressor. 
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.SetStaticModelData(System.Byte[])">
            Parse and update the static model data.
            
            @param   byte[] - mode data buffer
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.Decompress``1(System.Byte[],System.Int32)">
            Decompresses data from a byte array into an unordered array of structs.
            
            @param   byte[] data to decode.
            @param   int offset to begin decoding at.
            @return  T[] decoded struct array.
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DecompressData(System.Byte[],System.Int32,System.Int32,KS.Reactor.Secret.FrameSectionTypes,System.Int32@,System.Byte[]@)">
             Decompress stream data from a byte array into a new byte array.
             
             Case: Full/Partial frame + model => decode using the provided model then discard it.
             Case: Full/Partial frame + no model => decode using the static model
             Case: Update frame + model => decode using the provided model then store it.
             Case: Update frame + no model + model delta => apply delta to the model, decode the frame, then reconstruct a new update model
             Case: Update frame + no model + no delta => decode using the current update model
            
             @param   byte[] - buffer data
             @param   int - offset
             @param   int - object size
             @param   FrameSectionTypes frameSectionType
             @param   [out] int - object Count
             @param   [out] byte[] - decoded data
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DeserializeFullObjectModel(System.Byte[],System.Int32)">
             Decode the full object model.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Reactor.Secret.FLDecompressor`1.DeserializeUpdateObjectModel(System.Byte[],System.Int32)">
             Decode the update object model.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FLDecompressor`1.DecompressData(KS.Reactor.ksBitIStream,System.Int32,System.Byte[]@,System.Int32@)" -->
        <member name="T:KS.Reactor.Secret.FPObjectDecoder">
            This class is used to decode full object data compressed by FLCompressor.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPObjectDecoder.DecodeFullObject(KS.Reactor.ksBitIStream,System.Collections.Generic.List{KS.Reactor.Secret.FixedPointObject}@,System.Single@)" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPObjectDecoder.GetOutputObjects(System.Byte[],System.Int32)" -->
        <member name="T:KS.Reactor.Secret.FPTransformDecoder">
            This class is used to decode delta transform data compressed by FLCompressor.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPTransformDecoder.DecodeTransform(KS.Reactor.ksBitIStream,System.Collections.Generic.List{KS.Reactor.Secret.FixedPointTransform}@)" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.FPTransformDecoder.GetOutputTransforms(System.Byte[],System.Int32)" -->
        <member name="T:KS.Reactor.Secret.FrameDecoder">
            Decode a server frame and subsequently extracting and decoding frame sections data.
        </member>
        <member name="T:KS.Reactor.Secret.FrameDecoder.Config">
            Configuration settings for decoding frame data.
        </member>
        <member name="P:KS.Reactor.Secret.FrameDecoder.SyncRate">
            Number of frames synced per server update
        </member>
        <member name="P:KS.Reactor.Secret.FrameDecoder.SimulationRate">
            Unscale amount of time in microseconds that the server simulates per frame.
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.#ctor(KS.Reactor.Secret.FrameDecoder.Config)">
            Constructor
            
            @param   Config - configuration settings
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.CreateDecoder(KS.Reactor.Secret.EncoderTypes)">
            Construct a base frame section decoder for an encoding type
            
            @param   EncoderTypes
            @return  BaseFrameSectionDecoder
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.SetStaticModelData(System.Byte[])">
            Set new static model used by the decompressor
            
            @param   byte[] - mode data buffer
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.DecodeFrame(KS.Reactor.ksStreamBuffer,KS.Reactor.Client.ksBaseRoom)">
            Read the frame and parse out frame section headers and data
            
            @param   ksStreamBuffer - buffer containing a frame packet header and body
            @param   ksBaseRoom room
        </member>
        <member name="M:KS.Reactor.Secret.FrameDecoder.DecodeFrameSectionHeader(System.Byte[],System.Int32@,KS.Reactor.Secret.RoomUpdate,System.UInt32,KS.Reactor.Secret.BaseDecompressor,KS.Reactor.Secret.EntityArrayManager)">
            Decode the frame section header and data
            
            @param   byte[] encoded data
            @param   int data offset
            @param   uint length of encoded data
            @param   RoomUpdate frame data
        </member>
        <member name="T:KS.Reactor.Secret.FrameSectionTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.EncoderTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.CompressorTypes">
            Frame Section Types
        </member>
        <member name="T:KS.Reactor.Secret.SyncGroupHeader">
            Sync group header structure
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.ToString">
            Return a string summarizing this object.
            
            @return string
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.Deserialize(System.Byte[],System.Int32@)">
            Read header data from a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="M:KS.Reactor.Secret.SyncGroupHeader.Serialize(System.Byte[],System.Int32@)">
            Write header data to a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="T:KS.Reactor.Secret.SectionHeader">
            Section header structure
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.ToString">
            Return a string summarizing this object.
            
            @return string
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.Deserialize(System.Byte[],System.Int32@)">
            Read header data from a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="M:KS.Reactor.Secret.SectionHeader.Serialize(System.Byte[],System.Int32@)">
            Write header data to a byte array and increment the offset.
            
            @param   byte[] - data
            @param   ref int - offset
        </member>
        <member name="T:KS.Reactor.Secret.ICompressorUtility">
            Compressor utility class interface.
        </member>
        <member name="P:KS.Reactor.Secret.ICompressorUtility.UseUpdateServerTransform">
            Do we need to call UpdateServerTransform every server frame?
        </member>
        <member name="M:KS.Reactor.Secret.ICompressorUtility.UpdateServerTransform(KS.Reactor.Client.ksPhysicsState@,System.Single)">
            Advances the server transform one frame.
            
            @param   ref ksPhysicsState serverState
            @param   float serverDeltaTime
        </member>
        <member name="M:KS.Reactor.Secret.ICompressorUtility.OnNewServerPositionUpdate(System.Int32)">
            Called when a new server position is received.
            
            @param   int index of position that changed (1, 2, or 3 for x, y, or z).
        </member>
        <member name="M:KS.Reactor.Secret.ICompressorUtility.OnNewServerRotationUpdate">
            Called when a new server rotation is received.
        </member>
        <member name="T:KS.Reactor.Secret.ImpulseCompressorUtility">
            Utility class of the ImpulseCompressor, which send the delta transform without compression. 
            DiffCompressorUtility is used to smooth object movement on the client side.
            
            THIS IS CURRENTLY UNUSED
        </member>
        <member name="F:KS.Reactor.Secret.ImpulseCompressorUtility.Impulse">
            Impulse
        </member>
        <member name="F:KS.Reactor.Secret.ImpulseCompressorUtility.AngularImpulse">
            Angular Impulse
        </member>
        <member name="P:KS.Reactor.Secret.ImpulseCompressorUtility.UseUpdateServerTransform">
            We need to call UpdateServerTransform every frame.
        </member>
        <member name="M:KS.Reactor.Secret.ImpulseCompressorUtility.UpdateServerTransform(KS.Reactor.Client.ksPhysicsState@,System.Single)">
            Advances the server transform one frame.
            
            @param   ref ksPhysicsState serverState
            @param   float serverDeltaTime
        </member>
        <member name="M:KS.Reactor.Secret.ImpulseCompressorUtility.OnNewServerPositionUpdate(System.Int32)">
            Set skip position update flag on position of index to true
            
            @param   int index of position
        </member>
        <member name="M:KS.Reactor.Secret.ImpulseCompressorUtility.OnNewServerRotationUpdate">
            Set skip rotation update flag on rotation to true
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder">
            Handles the decoding of packet data from stream buffers.
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder.AuthenticationResult">
            Authentication response packet data
        </member>
        <member name="T:KS.Reactor.Secret.PacketDecoder.PingResult">
            Ping response packet data
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeFrameDecoderConfigs(KS.Reactor.ksStreamBuffer)">
            Decode frame decoder configs from a streambuffer
            
            @param   ksStreamBuffer - buffer
            @return  FrameDecoder.Config
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeStaticModelData(KS.Reactor.ksStreamBuffer)">
            Decode static model data from a streambuffer
            
            @param   ksStreamBuffer - buffer
            @return  byte[]
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodeAuthenticationResponse(KS.Reactor.ksStreamBuffer)">
            Decode an authentication result from a stream buffer. 
            If the authentication succeeded, the result will contain the local player ID.
            If the authentication failed, the result will contain a connect status value and a custom status value.
            
            @param   ksStreamBuffer - buffer
            @return  AuthenticationResult
        </member>
        <member name="M:KS.Reactor.Secret.PacketDecoder.DecodePong(KS.Reactor.ksStreamBuffer)">
            Decode a ping response (pong) from a stream buffer.
            Pong messages contain a type and the tick count of when the ping was sent.
            
            @param   ksStreamBuffer - buffer
            @return  PingResult
        </member>
        <member name="T:KS.Reactor.Secret.PacketEncoder">
            Handles the encoding of data and the writing of packet headers and bodies to stream buffers.
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.GetVersion">
            Get the version information for this encoder.
            
            @return  VersionInfo
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeRouting(System.UInt32,KS.Reactor.ksStreamBuffer)">
            Write a routing packet to a stream buffer.
            
            @param   uint - roomId
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeValidateModel(System.Byte[],KS.Reactor.ksStreamBuffer)">
            Write a model validation packet to a stream buffer.
            
            @param   byte[] - Checksum data for the current frame decoder model.
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeAuthentication(KS.Reactor.ksPlayerAPI.Session,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write an authentication packet to a stream buffer.
            
            @param   ksPlayerAPI.Session - Player session
            @param   ksMultiType[] - Authentication arguments
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeRoomRPC(System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write a room rpc packet to a stream buffer.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeEntityRPC(System.UInt32,System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)">
            Write an entity rpc packet to a stream buffer.
            
            @param   uint - Entity ID
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
            @param   ksStreamBuffer - buffer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.PacketEncoder.EncodeEntityBatchRPC(System.Collections.Generic.IEnumerable{KS.Reactor.ksIEntity},System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksStreamBuffer)" -->
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeRPC(System.UInt32,KS.Reactor.ksMultiType[],KS.Reactor.ksBitOStream)">
            Write an RPC message to a bit stream.
            
            @param   uint - RPC ID
            @param   ksMultiType[] - RPC arguments
            @param   ksBitOStream - Bit stream
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeFullInput(KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput,KS.Reactor.ksStreamBuffer)">
            Write a full input packet to a stream buffer.
            
            @param   ksInputRegistrar - Input registrar
            @param   ksInput - Input state
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeInput(KS.Reactor.ksInputRegistrar,KS.Reactor.ksInput,KS.Reactor.ksStreamBuffer)">
            Write an input packet to a stream buffer.
            
            @param   ksInputRegistrar - Input registrar
            @param   ksInput - Input state
            @param   ksStreamBuffer - buffer
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodePing(KS.Reactor.ksStreamBuffer,System.Boolean)">
            Write a ping packet to a stream buffer.
            
            @param   ksStreamBuffer - buffer
            @param   bool - True if this is an RPC ping.
        </member>
        <member name="M:KS.Reactor.Secret.PacketEncoder.EncodeIdle(KS.Reactor.ksStreamBuffer)">
            Write a idle packet to a stream buffer.
            
            @param   ksStreamBuffer - buffer
        </member>
        <member name="T:KS.Reactor.Secret.PacketHeader">
            Structure that contains data and enums for the Reactor packet protocol.
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO">
            Reads and writes Reactor packets to a connection object. Manages routing of read packets to appropriate packet handlers.
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO.WriteHandler">
            Handler to be invoked when a packet is written to a connection.
            
            @param   ksConnection - Connection that was written to.
            @param   ksStreamBuffer - Buffer that will be written to the connection.
            @param   SocketError - Write errors
        </member>
        <member name="T:KS.Reactor.Secret.PacketIO.ReadHandler">
            Handler to be invoked when a packet (header+body) is read from a connection.
            
            @param   ksConnection - Connection that was read from.
            @param   ksStreamBuffer - Buffer containing the packet header and body.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.WriteOperation.#ctor(KS.Reactor.ksStreamBuffer,KS.Reactor.Secret.PacketIO.WriteHandler)">
            Constructor.
            
            @param   ksStreamBuffer - Stream buffer operated on.
            @param   WriteHandler - Callback to invoke when the write operation completes.
        </member>
        <member name="P:KS.Reactor.Secret.PacketIO.IsReading">
            Return true if the packet reader is actively reading from a connection.
            
            @return  bool
        </member>
        <member name="P:KS.Reactor.Secret.PacketIO.Connection">
            Bound connection
            
            @return  ksConnection
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.#ctor(KS.Reactor.Client.ksConnection)">
            Constructor.
            
            @param   ksConnection - Connection that the packet reader will operate on.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.AddHandler(KS.Reactor.Secret.PacketHeader.Types,KS.Reactor.Secret.PacketIO.ReadHandler)">
            Add a handler for a type of packet
            
            @param   PacketHeader.Types - Packet type
            @param   ReadHandler - Callback to invoke when the specified packet is read from a connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.RemoveHandler(KS.Reactor.Secret.PacketHeader.Types)">
            Remove a handler for a type of packet
            
            @param   PacketHeader.Types - Packet type
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.BeginRead">
            Begin reading packets from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.StopRead">
            Stop reading packets from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.ReadNext">
            Read the next packet from the connection.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.Write(KS.Reactor.ksStreamBuffer,KS.Reactor.Secret.PacketIO.WriteHandler)">
            Write buffer data containing packet data to the bound connection.
            
            @param   ksStreamBuffer - Buffer containing a packet header and body.
            @param   WriteHandler - Callback to invoke once the write completes.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleReceiveHeader(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
            Handle recevied packet headers.
            Check the header for the amount of body data expected and begin a new read operation for that data.
            If the body length is 0, then pass the data to the body handler.
            
            @param   ksConnection - Connection that was read from.
            @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
            @param   SocketError - Read error.
            @param   object - Async state object.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleReceiveBody(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
             Handle recevied packet body.
             Read the header data and look for an appropriate packet handler. 
            
             @param   ksConnection - Connection that was read from.
             @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
             @param   SocketError - Read error.
             @param   object - Async state object.
        </member>
        <member name="M:KS.Reactor.Secret.PacketIO.HandleSend(KS.Reactor.Client.ksConnection,KS.Reactor.ksStreamBuffer.Segment,System.Net.Sockets.SocketError,System.Object)">
             Handle the completion of a write operation to a connection.
            
             @param   ksConnection - Connection that was read from.
             @param   ksStreamBuffer.Segment - Buffer segment that contains the header data.
             @param   SocketError - Read error.
             @param   object - Async state object.
        </member>
        <member name="T:KS.Reactor.Secret.QuantizationUtility">
            This class contains utility methods for quantization and dequantization.
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.IntArrayToVector3(System.Int32[],System.Single)">
            Dequantize int array to a ksVector3.
            
            @param   int[] array
            @param   float precision
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.DecodeQuaternion(System.Int32[],System.Int32)">
            Decode a quaternion from quantized smallest three and the index of the biggest element.
            
            @param   int[] qInt - smallest three of the quaternion
            @param   int maxValue - max possible value
            @return  ksQuaternion
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.DecodeQuaternion(System.Int32[],KS.Reactor.ksQuaternion@,System.Int32)">
            Decode a quaternion from quantized smallest three and the index of the biggest element.
            
            @param   int[] qInt - smallest three of the quaternion and the index of the biggest element
            @param   out ksQuaternion q - smallest three of the quaternion
            @param   int maxValue - max possible value
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ToIntArray(System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Int32[])">
            Form an int array from uints and their signs.
            
            @param   uint X
            @param   uint Y
            @param   uint Z
            @param   bool negX
            @param   bool negY
            @param   bool negZ
            @param   int[] intArray
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretVector(System.UInt32,System.UInt32,System.UInt32)">
            Convert the uint x, y, z values into floats via bit reinterpretation
            
            @param   uint X value
            @param   uint Y value
            @param   uint Z value
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretVector(System.Int32[])">
            Reinterpret an int array's first three values to floats then put them in a ksVector3 and return.
            
            @param   int[] int array
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ReinterpretToIntArray(System.UInt32,System.UInt32,System.UInt32,System.Int32[])">
            Reinterpret three uints to ints and put them in the given int array.
            
            @param   uint X value
            @param   uint Y value
            @param   uint Z value
            @param   int[] int array
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.IntAddition(System.Int32[],System.Int32[],System.Single)">
            Apply delta array on to last value array and convert the result to a ksVector3.
            
            @param   int[] last
            @param   int[] delta
            @param   float precision
            @return  ksVector3
        </member>
        <member name="M:KS.Reactor.Secret.QuantizationUtility.ApplyDelta(System.Int32[],System.Int32[])">
            Apply delta.
            
            @param   int[] last
            @param   int[] delta
        </member>
        <member name="T:KS.Reactor.Secret.RoomUpdate">
            RoomUpdate stores decoded frame data and applies updates during the ksBaseRoom update
        </member>
        <member name="T:KS.Reactor.Secret.RoomUpdate.SyncObjectUpdateType">
            Type of SyncObjectUpdate.
        </member>
        <member name="T:KS.Reactor.Secret.RoomUpdate.SyncObjectUpdate">
            Frame data for updating an entity's transform.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.SyncObjectUpdate.Type">
            Type.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.SyncObjectUpdate.NewValue">
            New value.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.SyncObjectUpdate.Teleported">
            Was the entity teleported?
        </member>
        <member name="T:KS.Reactor.Secret.RoomUpdate.ControllerUpdate">
            Controller update data.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.ControllerUpdate.Type">
            Constroller type.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.ControllerUpdate.AssetId">
            Constroller asset id.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.ControllerUpdate.#ctor(System.UInt32,System.UInt32)">
            Constructor
            
            @param   uint type of controller.
            @param   uint assetId of the controller.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.Room">
            Room.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.Frame">
            Frame number.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.ServerTime">
            Total amount of time simulated on the server.
        </member>
        <member name="P:KS.Reactor.Secret.RoomUpdate.ServerDeltaTime">
            Amount of time simulated on the server since the last frame.
        </member>
        <member name="F:KS.Reactor.Secret.RoomUpdate.ApplyDeltaEveryUpdate">
            Apply delta for every room update?
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.#ctor(KS.Reactor.Client.ksBaseRoom)">
            Constructor 
            
            @param   ksBaseRoom
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddInputAck(System.Int32)">
            Store input acknowledgements for this frame
            
            @param   int input acknowledgements
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.FindOrCreateSyncObject(System.UInt32,System.Boolean)">
            Find or create a new sync object.  If the sync object is new then store it in the new sync object list.
            
            @param   uint entity id
            @return  SyncObject
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.FindOrCreatePlayer(System.UInt32)">
            Find or create a new player.  If the player is new then store the player id in the new player id list.
            
            @param   uint player id
            @return  ksBasePlayer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.RoomUpdate.SetRoomProperties(System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[])" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.RoomUpdate.SetEntityProperties(System.UInt32,System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[])" -->
        <!-- Badly formed XML comment ignored for member "M:KS.Reactor.Secret.RoomUpdate.SetPlayerProperties(KS.Reactor.Client.ksBasePlayer,System.Collections.Generic.KeyValuePair{System.UInt32,KS.Reactor.ksMultiType}[])" -->
        <member name="M:KS.Reactor.Secret.RoomUpdate.SetGravity(KS.Reactor.ksVector3)">
            Store a new gravity value for the room and trip the update gravity flag.
            
            @param   ksVector3 gravity
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddEvent(KS.Reactor.Secret.BaseServerEvent)">
            Store a server event.
            
            @param   BaseServerEvent serverEvent
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.SortEvents">
            Sort the server events.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddSyncObjectUpdate">
            Store a transform update for every sync object.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddSyncObjectUpdate(KS.Reactor.Client.SyncObject,KS.Reactor.Secret.RoomUpdate.SyncObjectUpdateType,System.Int32[],System.Boolean)">
            Store a sync object transform update.
            
            @param   SyncObject syncObj
            @param   SyncObjectupdateType updateType
            @param   int[] newValue
            @param   bool teleported
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.AddControllerUpdate(KS.Reactor.Client.SyncObject,System.UInt32,System.UInt32)">
            Stores an update to change the controller on a sync object.
            
            @param   syncObject syncObj to change controller on.
            @param   uint controllerType - type of new controller.
            @param   uint assetId - asset id of the controller.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.Process">
            Apply all stored updates to the room.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.ApplySyncObjectUpdates">
            Apply the transform updates to the sync objects.
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.FirstThreeAreZeros(System.Int32[])">
            Returns true if first three elements in the given array are zeros.
            
            @param   int[] array to check
            @return  bool
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.RemoveSyncGroup(System.UInt32)">
            Add a sync group to the set of all sync groups the user no longer belongs to.
            
            @param   uint Sync group
        </member>
        <member name="M:KS.Reactor.Secret.RoomUpdate.RemoveSyncGroupEntity(System.UInt32,System.UInt32)">
            Add an entity ID to set of all entities removed from a sync group.
            
            @param   uint Sync group
            @param   uint Entity ID
        </member>
        <member name="T:KS.Reactor.Secret.ServerEventList">
            Build and process lists of server events.
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.#ctor(KS.Reactor.Client.ksBaseRoom)">
            Constructor
            
            @param   ksBaseRoom room
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.AddEvent(KS.Reactor.Secret.BaseServerEvent)">
            Add a server event to the list
            
            @param   BaseServerEvent serverEvent
        </member>
        <member name="M:KS.Reactor.Secret.ServerEventList.ProcessEvents">
            Processes the event queue.
        </member>
        <member name="T:KS.Reactor.Secret.BaseServerEvent">
            Base event.  Events are sorted by their ID and are executed based on type
        </member>
        <member name="T:KS.Reactor.Secret.RoomRPCServerEvent">
            Room RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.EntityRPCServerEvent">
            Entity RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.BatchRPCServerEvent">
            Batch RPC Event
        </member>
        <member name="T:KS.Reactor.Secret.DestroyEntityServerEvent">
            Destroy Entity Event
        </member>
        <member name="T:KS.Reactor.Secret.ClientConnectServerEvent">
            Client Connect Event
        </member>
        <member name="T:KS.Reactor.Secret.ClientDisconnectServerEvent">
            Client Disconnect Event
        </member>
        <member name="T:KS.Unity.ksPathFinderAttribute">
            File and directory path finder attribute tag
        </member>
        <member name="M:KS.Unity.ksPathFinderAttribute.#ctor(System.Boolean,System.String,System.Boolean)">
            Constructor
            
            @param   bool dirOnly - only allow selecting directories.
            @param   string title for the file browser.
            @param   string relative - if true and the path is in the project, will make the path relative to the
                     project.
        </member>
        <member name="T:KS.Compression.BaseEncoderModel">
            Base class for all encoder models.
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.CompressorId">
             Returns a byte id of the compressor that uses this model.
            
             @return   byte id unique to the compressor
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Version">
             Returns the version of the compressor
            
             @return   ushort version of the compressor
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Serialize(System.IO.BinaryWriter)">
             Serializes the model.
            
             @param   BinaryWriter writer
        </member>
        <member name="M:KS.Compression.BaseEncoderModel.Deserialize(System.Byte[])">
             Deserializes the model.
             The model data must starts with 7 byte header data:
             byte compressor Id
             uin16_t version
             uint length
            
             @param   byte[] modelData
             @return  bool - true if the model is set successfully
        </member>
        <member name="T:KS.Compression.BFEncoderModel">
            This class contains the probabilities used in the binary flag encoder/decoder.
            It also tracks the stats to generate the dynamic model.
        </member>
        <member name="M:KS.Compression.BFEncoderModel.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.#ctor(KS.Compression.BFEncoderModel)">
             Copy constructor
            
             @param   BFEncoderModel model to copy from
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Finalize">
            Destructor.
        </member>
        <member name="M:KS.Compression.BFEncoderModel.CompressorId">
             Returns a byte id of the compressor that uses this model.
            
             @return   byte id unique to the compressor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Version">
             Returns the version of the compressor
            
             @return   ushort version of the compressor
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Serialize(System.IO.BinaryWriter)">
             Serializes the model.
            
             @return  BinaryWriter writer
        </member>
        <member name="M:KS.Compression.BFEncoderModel.Deserialize(System.Byte[])">
             Deserializes the model.
             The model data byte array contains:
             8 probabilities for the full object flag bits
             58 probabilities for the update object flag bits
             2 probabilities for the object flag bit
             24 probabilities for the sign bits
             Each probability is stored as a uint. Therefore the model data should contains 368 bytes.
            
             @param   byte[] modelData
             @return  bool - true if the model is set successfully
        </member>
        <member name="M:KS.Compression.BFEncoderModel.DeserializeFullObjectModel(System.Byte[],System.Int32@)">
             Decode the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BFEncoderModel.DeserializeUpdateObjectModel(System.Byte[],System.Int32@)">
             Decode the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BFEncoderModel.ComputeProbabilities(System.Boolean)">
             Computes probabilities from the stats.
            
             @param   bool isFullObject
        </member>
        <member name="M:KS.Compression.BFEncoderModel.ComputeProbability(System.Int64,System.Int64)">
             Computes a probability from the given total bit count and one bit count.
            
             @param   long totalBitCount
             @param   long oneBitCount
             @return  uint probability
        </member>
        <member name="M:KS.Compression.BFEncoderModel.AddFullStats(KS.Compression.BFModelStats)">
             Adds the given full object stats.
            
             @param   BFModelStats fullFlagStats
        </member>
        <member name="M:KS.Compression.BFEncoderModel.AddUpdateStats(KS.Compression.BFModelStats,KS.Compression.BFModelStats)">
             Adds the given update object stats.
            
             @param   BFModelStats updateFlagStats
             @param   BFModelStats signBitsStats
        </member>
        <member name="T:KS.Compression.BFModelStats">
            Tracks the stats that are used to generate the binary flag model.
        </member>
        <member name="M:KS.Compression.BFModelStats.#ctor(System.UInt32)">
             Constructor
            
             @param   uint size of stats array
        </member>
        <member name="M:KS.Compression.BFModelStats.ClearStats">
            Clears the stats.
        </member>
        <member name="M:KS.Compression.BFModelStats.Add(KS.Compression.BFModelStats)">
             Adds the given stats to these stats.
            
             @param   BFModelStats stats
        </member>
        <member name="M:KS.Compression.BFModelStats.Subtract(KS.Compression.BFModelStats)">
             Subtracts the given stats from these stats.
             If the values in the given stats is bigger than these stats', set the values to 0.
            
             @param   BFModelStats stats
        </member>
        <member name="M:KS.Compression.BFModelStats.Deserialize(System.Byte[],System.Int32@)">
             Decode the stats.
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Compression.BinArithCoder">
            Binary arithmetic coder base class.
            Common methods, constants and data as used for encoding and decoding of binary
            arithmetic stream.
        </member>
        <member name="M:KS.Compression.BinArithCoder.ClampProb(System.UInt32)">
             Returns a clamped value that is greater than zero and less than kProbMax.
            
             @param   uint prob
             @return  uint
        </member>
        <member name="T:KS.Compression.BinArithDecoder">
            Binary arithmetic decoder (Ilya Muravyov's variant).
            Decodes a string of binary (0/1) events with probabilities that are not 1/2.
            This code is written for clarity, not performance.
        </member>
        <member name="M:KS.Compression.BinArithDecoder.GetByte">
             Gets the next byte of data to decode.
            
             @return  byte
        </member>
        <member name="M:KS.Compression.BinArithDecoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinArithDecoder.Initialize(System.IO.BinaryReader)">
             Initialize
            
             @param   BinaryReader source - data to decode
        </member>
        <member name="M:KS.Compression.BinArithDecoder.Decode(System.UInt32)">
             Decodes a binary symbol with the probability of a 1 being "prob".
            
             @param   uint prob to decode the next bit with
             @return  int - decoded bit
        </member>
        <member name="M:KS.Compression.BinArithDecoder.DecodeWithBitSwitchProb(System.Int32,System.UInt32)">
             Decodes with the given bit as the context. If the context bit is zero,
             use the given probability. Otherwise, use kProbMax - prob.
            
             @param   int context bit
             @param   uint prob
             @return  int - decoded bit
        </member>
        <member name="T:KS.Compression.BinArithEncoder">
            Binary arithmetic encoder (Ilya Muravyov's variant).
            Encodes a string of binary (0/1) events with probabilities that are not 1/2.
            This code is written for clarity, not performance.
        </member>
        <member name="M:KS.Compression.BinArithEncoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Initialize(System.IO.BinaryWriter)">
             Initialize
            
             @param    BinaryWriter  target - buffer to encode data to
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Written">
            Get the number of written bytes
            
            @return  int  bytes written
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.BinArithEncoder.Encode(System.Int32,System.UInt32)" -->
        <member name="M:KS.Compression.BinArithEncoder.EncodeWithBitSwitchProb(System.Int32,System.Int32,System.UInt32)">
             Encodes the given bit with another bit as the context. If the context bit is zero,
             use the given probability. Otherwise, use kProbMax - prob.
            
             @param   int bit to encode
             @param   int context bit
             @param   uint prob
        </member>
        <member name="M:KS.Compression.BinArithEncoder.Flush">
            Finish encoding. Flushes remaining codeword.
        </member>
        <member name="T:KS.Compression.BinaryFlagDecoder">
            Decoder for data encoded by BinaryFlagEncoder.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.SetStaticModel(System.Byte[])">
            Sets the static model.
            
            @param   byte[] modelData
            @return  bool true if the static model was set successfully
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.SetUseStaticModel(System.Boolean,System.Boolean)">
            Toggles using static model for decoding full objects and update objects.
            
            @param   bool useForFullObject
            @param   bool useForUpdateObject
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.Initialize(KS.Compression.EncodedData,System.Boolean)">
            Initializes the data structures required to decode data
            
            @param   EncodedData encodedData
            @param   bool useDefaultModel
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.Decode">
            Decodes encoded data.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeObject(System.Int32,System.UInt32[0:,0:])">
             Decodes the object at the given index.
            
             @param   int objectIndex
             @param   uint[,] signBitProbsWithContext
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeFullObjectFlags">
            Decode full object flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeFieldBitSizes">
            Decode field sizes.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeUpdateObjectFlags">
            Decode update object flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DecodeUpdateObjectFieldFlags(System.Int32@,System.Boolean,System.UInt32[])">
             Decodes update object field flags.
            
             @param   ref int flagBitIndex
             @param   bool skipFieldBit - if true, skip decoding of the bit for the field
             @param   uint[] updateObjectFlagBitProbs
             @return  byte flag
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DeserializeFullObjectModel(System.Byte[],System.Int32@)">
             Deserializes the full object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="M:KS.Compression.BinaryFlagDecoder.DeserializeUpdateObjectModel(System.Byte[],System.Int32@)">
             Deserializes the update object model
            
             @param   byte[] data
             @param   ref int offset
        </member>
        <member name="T:KS.Compression.BinaryFlagEncoder">
            This encoder generates flags for fields to indicate if they are zero, then uses binary arithmetic encoding to
            encode the objects by columns with the probabilities of bit switching for each column.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.SetStaticModel(System.Byte[])">
            Sets the static model.
            
            @param   byte[] modelData
            @return  bool true if the static model was set successfully
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.SetUseStaticModel(System.Boolean,System.Boolean)">
            Toggles using static model for encoding full objects and update objects.
            
            @param   bool useForFullObject
            @param   bool useForUpdateObject
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.Initialize(KS.Compression.EncodedData,System.Boolean)">
             Initializes
            
             @param   EncodedData encodedData
             @param   bool useDefaultModel
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.GenerateFlags">
            Generates flags.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.Encode">
            Encodes raw data.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeObject(System.Int32,System.UInt32[0:,0:])">
             Encodes the object at the given index.
            
             @param   int objectIndex
             @param   uint[,] signBitProbsWithContext
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeFullObjectFlags">
            Encodes full object flags.
            Full object flag uses 8 bits:
            1 bit for the position. 1 bit for each position element.
            1 bit for the rotation. 1 bit for each rotation element.
            If the position or rotation bit is 0, then we don't encode the bits for the position or rotation elements,
            otherwise at least one element bit has to be 1.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeFieldBitSizes">
            Encodes field sizes. It uses 6 bits to store the maximum bit size of the biggest value of a field.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeUpdateObjectFlags">
            Encodes update object flags.
            Update object's flag uses 58 bits: 1 bit for the object.
            For each transform vector(position, rotation and scale):
            1 bit for the vector, 1 bit for each vector element, 5 bits for the field size.
            If the object bit is 0, then we just encode this 0 bit.
            Otherwise, if the vector bit is 0, then we encode the vector bit but not the element bits.
            If the vector bit is 1, then at least one vector element bit has to be 1.
            If the vector element bit is 0, then we don't encode the field size.
        </member>
        <member name="M:KS.Compression.BinaryFlagEncoder.EncodeUpdateObjectFieldFlags(System.Byte,System.Int32@,System.Boolean,System.UInt32[])">
             Encodes update object field flags.
             Encodes the bit for the field first. If it is not 0, encodes the field size.
            
             @param   byte flag
             @param   ref int flagBitIndex
             @param   bool skipFieldBit - if true, don't encode the bit for the field
             @param   uint[] updateObjectFlagBitProbs
             @return  bool - true if the field bit is 0
        </member>
        <member name="T:KS.Compression.EncodedData">
            Class used for tracking encoded data
        </member>
        <member name="M:KS.Compression.EncodedData.#ctor">
            Constructor
        </member>
        <member name="T:KS.Compression.FieldFlag">
            This class generates and encodes/decodes flags indicating if each field(position, rotation, scale) is zero.
        </member>
        <member name="M:KS.Compression.FieldFlag.#ctor">
            Constructor
        </member>
        <member name="M:KS.Compression.FieldFlag.Initialize(System.Int32,System.Int32)">
             Initialize
            
             @param   int objSize
             @param   int objCount
        </member>
        <member name="M:KS.Compression.FieldFlag.IsZeroField(System.Int32,System.Int32)">
             Checks if the field starts at the given byte is zero.
            
             @param   int objIndex
             @param   int byteIndex
             @return  true if the field is zero
        </member>
        <member name="M:KS.Compression.FieldFlag.GetFieldSize(System.Int32,System.Int32)">
             Gets field size.
            
             @param   int objIndex
             @param   int byteIndex
             @return  byte field size
        </member>
        <member name="M:KS.Compression.FieldFlag.SkipUpdateObject(System.Int32)">
             Checks if we can skip the given update object for encoding.
            
             @param   int objIndex
             @return  true if we can skip this object
        </member>
        <member name="T:KS.Compression.FieldFlagGenerator">
            This class generates the field flags indicating if each field(position, rotation, scale) is zero.
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateFullObjectFlags(KS.Compression.FieldFlag,System.IO.BinaryReader)">
             Generates field bit sizes and fields flags for the full object data.
            
             @param   FieldFlag fieldFlag
             @param   BinaryReader srcData
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateUpdateObjectFlags(KS.Compression.FieldFlag,System.IO.BinaryReader)">
             Generates field bit sizes and fields flags for the update object data.
            
             @param   FieldFlag fieldFlag
             @param   BinaryReader srcData
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateTransformFlags(KS.Compression.FieldFlag,System.Int32,System.IO.BinaryReader)">
             Generates flags for the position or the rotation or the scale.
            
             @param   FieldFlag fieldFlag
             @param   int flagIndex
             @param   BinaryReader data
             @param   ref int position
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GenerateFieldFlags(KS.Compression.FieldFlag,System.Int32,System.IO.BinaryReader)">
             Generates flag for the given field data.
             We use 1 bit for the field not being zero and 5 bits for the field bit size.
            
             @param   FieldFlag fieldFlag
             @param   int flagIndex
             @param   BinaryReader data
             @param   int position
        </member>
        <member name="M:KS.Compression.FieldFlagGenerator.GetMostSignificantBitIndex(System.UInt32)">
             Gets the index of the most significant bit of a uint.
            
             @param   uint value
             @return  byte index
        </member>
        <member name="M:KS.Compression.FLBinaryTreeDecoder.ReverseDiff">
            Perform a reverse diff(replace different bits) from the encoded array to the data array
        </member>
        <member name="M:KS.Compression.FLByteDiffDecoder.ReverseDiff">
            Perform a reverse diff(replace different bytes) from the encoded array to the data array
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLDecoder.Initialize(System.Byte[],System.Collections.Generic.List{System.UInt32},System.Int32,System.Int32,System.Byte[]@)" -->
        <member name="M:KS.Compression.FLDecoder.ReverseDiff">
            Perform a reverse diff(sequential additions) from the encoded array to the data array
        </member>
        <member name="M:KS.Compression.FLDecoder.DecompressDelta(System.Int32,System.Byte[])">
             Compress and copy the delta and its length (max 255 bytes) to the destination
            
             @param   int index offset in bytes to the header for the next expected delta
             @param	byte[] delta data
             @return	int index to the next delta location
        </member>
        <member name="M:KS.Compression.FLDecoder.ReverseApplyModel(System.Int32)">
             Copy remapped bits from the source object to the destination object
            
             @param   int index of the start byte of the target object to remap
        </member>
        <member name="M:KS.Compression.FLDecoder.GetDecoderTasks(System.Int32)">
            Generate a queue of concurrent tasks for decoding.
            
            @param   int taskCount number of tasks to generate
            @return  DecoderTask[] list of tasks that can be executed concurrently
        </member>
        <member name="M:KS.Compression.FLDecoder.InitializeBitCounts">
            Initialize bit counts.
        </member>
        <member name="M:KS.Compression.FLDecoder.GetBitCounts">
            Return bit counts
            
            @return  uint[]
        </member>
        <member name="P:KS.Compression.FLEncoder.Deltas">
            Encoded deltas
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoder.Initialize(System.Collections.Generic.List{System.UInt32},System.Int32,System.Int32,System.Byte[])" -->
        <member name="M:KS.Compression.FLEncoder.ApplyModel(System.Int32)">
             Copy remapped bits from the source object to the destination object
            
             @param	int index of the target object for bit remapping
        </member>
        <member name="M:KS.Compression.FLEncoder.GetEncoderTasks(System.Int32)">
            Generate a queue of concurrent tasks for encoding.
            
            @param taskCount number of tasks tp generate
        </member>
        <member name="M:KS.Compression.FLEncoder.Sort">
            Sort the object indices
        </member>
        <member name="M:KS.Compression.FLEncoder.Diff">
            Calculate and store the difference between each sorted object
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoder.Subtract(System.Int32,System.Int32,System.Byte[])" -->
        <member name="M:KS.Compression.FLEncoder.CompressDelta(System.Byte[])">
             Compress and copy the delta and its length (max 255 bytes) to the destination
            
             @param	byte[] delta
             @return	int number of bytes the delta was written as (includes size byte)
        </member>
        <member name="T:KS.Compression.FLEncoderModel">
            Generates the model for fixed-length object encoder.
            The model is a remapping of bits, where the bits are 
            remapped from most significant to least significant
            (little-endian), ordered by lowest variance to highest, 
            then by lowest mean to highest
        </member>
        <member name="T:KS.Compression.FLEncoderModel.BitStats">
            Structure that stores bit statistics
        </member>
        <member name="P:KS.Compression.FLEncoderModel.SerializedModel">
            Get/Set the serialized model data
        </member>
        <member name="M:KS.Compression.FLEncoderModel.#ctor">
            Construct a new FLEncoderModel and assign the default model.
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.SetModelData(System.Collections.Generic.List{System.UInt32})" -->
        <member name="M:KS.Compression.FLEncoderModel.Initialize(System.Byte[],System.Int32,System.Int32)">
            Initializes the model. 
            
            @param   byte[] sourceData byte array containing source data?
            @param   int objSize the size of the objects to analyze
            @param   int objCount the number of objects to analyze
        </member>
        <member name="M:KS.Compression.FLEncoderModel.GetModelTasks(System.Int32)">
            Create a list of tasks that can be run concurrently
            
            @param   int taskCount number of tasks to generate.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.CountBits(System.Int32)">
             Add the bits from an object to the bit count totals
            
             @param	int byteOffset offset of the object data to analyze
        </member>
        <member name="M:KS.Compression.FLEncoderModel.CountBitsByNibble(System.Byte,System.Int32)">
             Examine the 4 lowest bits of a byte and add them to the bit count total
            
             @param	byte nibble data to analyze
             @param	int bitOffset location of bit counter
        </member>
        <member name="M:KS.Compression.FLEncoderModel.BuildModel">
            Construct a model from the bit counts
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.GetModel" -->
        <member name="M:KS.Compression.FLEncoderModel.SerializeModel">
            Serializes the model.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.DeserializeModel(System.Boolean)">
            Deserialize the model.
        </member>
        <member name="M:KS.Compression.FLEncoderModel.DeserializeModelData(System.Byte[],System.Int32@)">
            Deserialize model data from a source buffer.
            
            @param   byte[] - model data buffer
            @para    ref int - offset
        </member>
        <member name="M:KS.Compression.FLEncoderModel.ParseModelData(System.Byte[])">
            Parse and construct a model object from a byte buffer
            
            @param   byte[] - model data buffer
        </member>
        <!-- Badly formed XML comment ignored for member "M:KS.Compression.FLEncoderModel.InsertBitposToFront(System.Collections.Generic.List{System.UInt32})" -->
        <member name="M:KS.Compression.FLEncoderModel.SetBitCounts(System.UInt32[])">
            Set bit counts.
            
            @param   uint[] bitCounts
        </member>
        <member name="M:KS.Compression.FLEncoderModel.ReadUInt32(System.Byte[],System.Int32@,System.UInt32)">
            Read uint from src starting from index with length
            @param	byte[] src - source byte array
            @param	ref int index of starting position
            @param	uint length of data to read
            @return  uint value read out
        </member>
        <member name="M:KS.Compression.FLEncoderModel.WriteBytes(System.Byte[],System.UInt32,System.UInt32,System.Int32@)">
            Writes up to 4 bytes into a byte array.
            
            @param   byte[] dest to write to.
            @param   uint value to write.
            @param   uint numBytes to write.
            @param   ref int index to write to. Will be increased by the number of bytes written.
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder">
            Decodes object diffs with probabilities generated from the last row.
            Returns the decoded data as a byte vector.
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.ReverseDiffFunction">
             Object reverse diff callback.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.DecodeFunction">
             Object decoding callback.
            
             @param   BinArithDecoder decoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader context
             @param   BinaryReader decoded
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayDecoder.DecodeParams">
            Class of the decoding parameters.
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.DecodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
             Constructor
            
             @param   byte[] encoded
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.DecodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,KS.Compression.Object2dArrayDecoder.ReverseDiffFunction,KS.Compression.Object2dArrayDecoder.DecodeFunction)">
             Constructor
            
             @param   byte[] encoded
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
             @param   int diffObjectSize
             @param   int bitNumberToDecodePerObject
             @param   ReverseDiffFunction reverseDiffFunction
             @param   DecodeFunction decodeFunction
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.Decode(KS.Compression.Object2dArrayDecoder.DecodeParams)">
             Decodes data with the given params.
            
             @param   DecodeParams decodeParams
             @return  byte[] - decoded data
        </member>
        <member name="M:KS.Compression.Object2dArrayDecoder.ReverseDiff(KS.Compression.Object2dArrayDecoder.DecodeParams,System.Byte[])">
             Iterate through all object diffs and call decodParams.ReverseDiff on them to get the original object data.
            
             @param   DecodeParams decodeParams
             @param   byte[] decodedData
        </member>
        <member name="T:KS.Compression.ReverseDiffFunctions">
            This class contains the reverse diff functions for different data structures.
        </member>
        <member name="M:KS.Compression.ReverseDiffFunctions.Xor(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Performs an XOR of all bytes on object x with object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.ReverseDiffFunctions.ReverseDiffSingleFloatComponents(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Combines the mantissa, exponent, and sign components of all floats in object x with object y
             and store the results in object dest.
            
             @param   BinaryReader x - reader of the object diff data
             @param   BinaryReader y - reader of the object to apply diff data
             @param   BinaryWriter dest - writer of the result object
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.DecodeFunctions">
            This class contains the decode functions for different data structures.
        </member>
        <member name="M:KS.Compression.DecodeFunctions.DecodeAllBits(KS.Compression.BinArithDecoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Decodes the given length of data bit by bit.
            
             @param   BinArithDecoder decoder to decode the encoded bits
             @param   uint[] probs - probabilities to decode bits
             @param   int[] bitSwitchCount - record bit switch count to compute probabilities
             @param   BinaryReader context - context data used to switch probabilities
             @param   BinaryWriter decoded - output writer for the decoded data
             @param   int length
        </member>
        <member name="M:KS.Compression.DecodeFunctions.DecodeSingleFloatComponents(KS.Compression.BinArithDecoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Decodes mantissa diff, exponent diff and sign diff.
            
             @param   BinArithDecoder decoder to decode the encoded bits
             @param   uint[] probs - probabilities to decode bits
             @param   int[] bitSwitchCount - record bit switch count to compute probabilities
             @param   BinaryReader context - context data used to switch probabilities
             @param   BinaryWriter decoded - output writer for the decoded data
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder">
             This encoder encodes with the given EncodeParams.
             - EncodeParams.Source and EncodeParams.SourceLength defines the byte array of the source data.
             - With the EncodeParams.RowCount, EncodeParams.ColumnCount and EncodeParams.ObjectSize, the encoder can
               interpret the source data as a 2d object array.
             - The Diff function computes the diff between two objects and output a diff object of DiffObjectSize.
             - The Encode function encodes the diff data.
            
             The encoder encodes the objects in two steps:
             1. Diff. It diffs each object in the first column with the object in the last row, each object in the remaining
             columns with the object in the last column.
             2. Encode. It encodes each object with the probabilities generated from the last row. There is one probability
                for every bit need to encode for an object. It is the probability of the bit in the current object being
                different from the bit of the object in the last row or column. The very first object is encoded as it is
                since it has no object to diff with.
             The encoded data will be returned as a byte vector.
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.DiffFunction">
             Object diff callback.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.EncodeFunction">
             Object encoding callback.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
        <member name="T:KS.Compression.Object2dArrayEncoder.EncodeParams">
            Class of the encoding parameters.
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.EncodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
             Constructor
            
             @param   byte[] source
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.EncodeParams.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,KS.Compression.Object2dArrayEncoder.DiffFunction,KS.Compression.Object2dArrayEncoder.EncodeFunction)">
             Constructor
            
             @param   byte[] source
             @param   int rowCount
             @param   int columnCount
             @param   int objectSize
             @param   int diffObjectSize
             @param   int bitNumberToEncodePerObject
             @param   DiffFunction diffFunction
             @param   EncodeFunction encodeFunction
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.Encode(KS.Compression.Object2dArrayEncoder.EncodeParams)">
             Encodes data with the given params.
            
             @param   EncodeParams encodeParams
             @return  byte[] - encoded data
        </member>
        <member name="M:KS.Compression.Object2dArrayEncoder.Diff(KS.Compression.Object2dArrayEncoder.EncodeParams)">
             For the first column, diff the object with the one in the last row.
             For other columns, diff the object with the one in the last column.
            
             @param   EncodeParams encodeParams
        </member>
        <member name="T:KS.Compression.DiffFunctions">
            This class contains the diff functions for different data structures.
        </member>
        <member name="M:KS.Compression.DiffFunctions.Xor(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Performs an XOR of all bytes on object x with object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="M:KS.Compression.DiffFunctions.DiffSingleFloatComponent(System.IO.BinaryReader,System.IO.BinaryReader,System.IO.BinaryWriter,System.Int32)">
             Generates a difference of the mantissa, exponent, and sign components of all floats in object x with
             object y and store the results in object dest.
            
             @param   BinaryReader x - reader of the object to diff
             @param   BinaryReader y - reader of the object to diff with
             @param   BinaryWriter dest - writer of the diff data
             @param   int objectSize
        </member>
        <member name="T:KS.Compression.EncodeFunctions">
            This class contains the encode functions for different data structures.
        </member>
        <member name="M:KS.Compression.EncodeFunctions.EncodeAllBits(KS.Compression.BinArithEncoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryReader,System.Int32)">
             Encodes the given data bit by bit.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
        <member name="M:KS.Compression.EncodeFunctions.EncodeSingleFloatComponents(KS.Compression.BinArithEncoder,System.UInt32[],System.Int32[],System.IO.BinaryReader,System.IO.BinaryReader,System.Int32)">
             Encodes mantissa diff, exponent diff and sign diff data.
            
             @param   BinArithEncoder encoder
             @param   uint[] probs
             @param   int[] bitSwitchCount
             @param   BinaryReader source
             @param   BinaryReader context
             @param   int length
        </member>
    </members>
</doc>
